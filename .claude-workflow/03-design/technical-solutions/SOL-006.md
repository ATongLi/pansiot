# SOL-006: Scada工程编辑器整体布局与组件架构技术方案

## 元数据
- **方案ID**: SOL-006
- **关联功能**: FE-006
- **方案类型**: 架构 / UI
- **状态**: 已批准
- **设计人**: Claude
- **评审人**: 用户
- **创建日期**: 2026-01-23
- **评审日期**: 2026-01-23

## 背景和目标

### 背景
Scada平台需要为用户提供专业的HMI工程编辑能力。当用户完成新建工程或从文件打开工程后，需要在新的标签页中显示工程编辑界面。当前已有基础主页面框架（FE-001），但缺少完整的工程编辑器布局和组件架构。

### 目标
1. 实现专业的工程编辑器六区域布局
2. 构建模块化、可复用的UI组件架构
3. 建立完整的MobX状态管理体系
4. 为后续编辑功能提供坚实的界面基础
5. 遵循Scada样式指南（STYLE_GUIDE.md）保持视觉一致性

## 问题陈述

### 核心问题
如何设计一个既专业又高效的工程编辑器界面，使其：
- 符合工业软件的操作习惯（参考WPS、Visio等专业软件）
- 支持多工程同时编辑（标签页机制）
- 提供清晰的工程结构视图（左侧3个Tab）
- 提供便捷的属性编辑功能（右侧2个Tab）
- 保持与现有Scada主框架的视觉一致性

### 技术挑战
1. **组件数量多**: 16个子功能组件，需要合理的组件划分
2. **状态管理复杂**: 标签页状态、选中状态、面板状态需要统一管理
3. **布局动态性**: 右侧属性栏需要根据选中状态动态显示/隐藏
4. **性能要求**: 界面响应流畅，组件渲染高效

## 方案概述

采用**六区域布局架构**，使用React + MobX构建响应式界面，通过组件化设计实现16个UI组件。左侧导航栏提供工程、画面、组件三个Tab，右侧属性栏提供属性、图层两个Tab（默认隐藏）。整个编辑器作为独立模块集成到现有Scada主框架中。

**核心思路**：
- EditorLayout作为容器组件管理六区域布局
- MobX Store统一管理编辑器状态
- 组件职责单一，通过Props和Store通信
- CSS Variables统一样式，遵循STYLE_GUIDE.md
- Mock数据驱动初始开发，后续替换为真实逻辑

## 技术选型

| 技术领域 | 选型方案 | 理由 | 替代方案 | 对比分析 |
|---------|---------|------|---------|---------|
| **前端框架** | React 18.3.1 | 项目已使用，组件化能力强 | Vue 3 | React生态更成熟，MobX集成更好 |
| **状态管理** | MobX 6.12.0 | 项目已使用，响应式优秀 | Redux Toolkit | MobX更简洁，适合UI状态管理 |
| **样式方案** | Plain CSS + CSS Variables | 项目已使用，遵循STYLE_GUIDE.md | CSS-in-JS | 不引入额外依赖，样式统一 |
| **布局方案** | Flexbox | 响应式布局，兼容性好 | Grid | Flexbox更适合一维布局，Grid更适合二维 |
| **组件通信** | Props + MobX Store | 单向数据流，全局状态共享 | Event Bus | MobX已足够，无需额外Event Bus |
| **图标方案** | SVG线框图标 | 可缩放，样式可控，符合工业风格 | Icon Font | SVG更灵活，支持动态样式 |
| **类型系统** | TypeScript 5.x | 项目已使用，类型安全 | N/A | 必须使用，增强代码质量 |
| **桌面框架** | Electron | 项目已使用，跨平台桌面应用 | Tauri | Electron生态更成熟，文档完善 |

## 架构设计

### Electron 架构设计

Scada 基于 Electron 框架，采用多进程架构：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Electron Main Process                        │
│                    (Node.js Runtime)                            │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  WindowManager (窗口管理)                               │   │
│  │  - 创建/关闭窗口                                         │   │
│  │  - 窗口状态持久化                                        │   │
│  │  - 窗口尺寸、位置、最大化状态                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  FileManager (文件操作)                                 │   │
│  │  - 文件对话框 (打开/保存)                                │   │
│  │  - 工程文件读取/写入                                     │   │
│  │  - 最近文件列表管理                                      │   │
│  │  - 自动保存功能                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  MenuManager (菜单管理)                                 │   │
│  │  - 应用菜单 (文件/编辑/视图/工具/帮助)                   │   │
│  │  - 上下文菜单                                            │   │
│  │  - 菜单项与前端工具栏联动                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ShortcutManager (快捷键管理)                           │   │
│  │  - 全局快捷键注册                                        │   │
│  │  - 菜单快捷键                                            │   │
│  │  - 工具栏快捷键                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  NotificationManager (通知管理)                         │   │
│  │  - 系统通知                                              │   │
│  │  - 保存成功提示                                          │   │
│  │  - 错误/警告提示                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  IPC Handlers (进程间通信)                              │   │
│  │  - ipcMain.handle('project:open')                       │   │
│  │  - ipcMain.handle('project:save')                       │   │
│  │  - ipcMain.handle('project:save-as')                    │   │
│  │  - ipcMain.handle('dialog:open-file')                   │   │
│  │  - ipcMain.handle('dialog:save-file')                   │   │
│  │  - ipcMain.handle('window:get-state')                   │   │
│  │  - ipcMain.handle('recent-files:get')                   │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ↕ IPC Communication
┌─────────────────────────────────────────────────────────────────┐
│                  Renderer Process (React UI)                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  IPC Invokers (前端调用层)                              │   │
│  │  - ipcRenderer.invoke('project:open')                   │   │
│  │  - ipcRenderer.invoke('project:save')                   │   │
│  │  - ipcRenderer.invoke('dialog:open-file')               │   │
│  │  - ipcRenderer.on('project:autosave')                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  MobX Store (前端状态管理)                              │   │
│  │  - editorStore.openProject() 调用 IPC                   │   │
│  │  - editorStore.saveProject() 调用 IPC                   │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### IPC 通信设计

#### IPC 通道列表

| 通道名 | 方向 | 功能 | 参数 | 返回值 |
|--------|------|------|------|--------|
| **project:open** | Renderer→Main | 打开工程文件 | `{ filePath: string }` | `{ project: Project }` |
| **project:save** | Renderer→Main | 保存工程文件 | `{ project: Project, filePath: string }` | `{ success: boolean }` |
| **project:save-as** | Renderer→Main | 另存为工程 | `{ project: Project, filePath: string }` | `{ success: boolean }` |
| **project:autosave** | Main→Renderer | 自动保存通知 | `{ project: Project }` | N/A (Event) |
| **dialog:open-file** | Renderer→Main | 打开文件对话框 | `{ filters: FileFilter[] }` | `{ filePath: string \| null }` |
| **dialog:save-file** | Renderer→Main | 保存文件对话框 | `{ filters: FileFilter[], defaultPath: string }` | `{ filePath: string \| null }` |
| **window:get-state** | Renderer→Main | 获取窗口状态 | N/A | `{ width, height, x, y, isMaximized }` |
| **window:set-state** | Renderer→Main | 设置窗口状态 | `{ width, height, x, y }` | `{ success: boolean }` |
| **recent-files:get** | Renderer→Main | 获取最近文件列表 | N/A | `{ files: RecentFile[] }` |
| **recent-files:add** | Renderer→Main | 添加最近文件 | `{ filePath: string, projectName: string }` | `{ success: boolean }` |
| **notification:show** | Renderer→Main | 显示系统通知 | `{ title, message, type }` | `{ success: boolean }` |

#### IPC 调用示例

```typescript
// Renderer Process (React + MobX Store)
import { ipcRenderer } from 'electron';

class EditorStore {
  async openProject(filePath: string) {
    try {
      // 1. 调用 Main Process 读取工程文件
      const result = await ipcRenderer.invoke('project:open', { filePath });

      // 2. 更新 MobX 状态
      this.currentProject = result.project;
      this.projectTabs.push({
        id: generateId(),
        projectId: result.project.id,
        title: result.project.name,
        icon: 'project-icon',
        isDirty: false,
        isActive: true
      });

      // 3. 添加到最近文件列表
      await ipcRenderer.invoke('recent-files:add', {
        filePath,
        projectName: result.project.name
      });
    } catch (error) {
      // 显示错误通知
      await ipcRenderer.invoke('notification:show', {
        title: '打开工程失败',
        message: error.message,
        type: 'error'
      });
    }
  }

  async saveProject() {
    if (!this.currentProject) return;

    try {
      const filePath = this.currentProject.filePath || await this.showSaveDialog();

      if (!filePath) return; // 用户取消

      const result = await ipcRenderer.invoke('project:save', {
        project: this.currentProject,
        filePath
      });

      if (result.success) {
        // 清除未保存标识
        const activeTab = this.activeProjectTab;
        if (activeTab) {
          activeTab.isDirty = false;
        }

        // 显示成功通知
        await ipcRenderer.invoke('notification:show', {
          title: '保存成功',
          message: `工程 "${this.currentProject.name}" 已保存`,
          type: 'success'
        });
      }
    } catch (error) {
      await ipcRenderer.invoke('notification:show', {
        title: '保存失败',
        message: error.message,
        type: 'error'
      });
    }
  }
}

// 监听自动保存事件
ipcRenderer.on('project:autosave', (event, { project }) => {
  // 更新 UI 显示自动保存状态
  console.log('Auto-saved:', project.name);
});
```

### 主进程功能模块

#### 1. WindowManager (窗口管理器)

```typescript
// platforms/scada/packages/main/src/windowManager.ts

import { BrowserWindow, screen } from 'electron';

export class WindowManager {
  private mainWindow: BrowserWindow | null = null;

  createMainWindow(): BrowserWindow {
    const { width, height } = screen.getPrimaryDisplay().workAreaSize;

    this.mainWindow = new BrowserWindow({
      width: 1400,
      height: 900,
      minWidth: 1200,
      minHeight: 700,
      backgroundColor: '#f5f5f5',
      show: false, // 延迟显示，等待窗口内容加载
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js')
      }
    });

    // 窗口准备好后显示
    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow?.show();
    });

    // 持久化窗口状态
    this.mainWindow.on('close', () => {
      this.saveWindowState();
    });

    return this.mainWindow;
  }

  saveWindowState(): void {
    if (!this.mainWindow) return;

    const state = {
      width: this.mainWindow.getBounds().width,
      height: this.mainWindow.getBounds().height,
      x: this.mainWindow.getBounds().x,
      y: this.mainWindow.getBounds().y,
      isMaximized: this.mainWindow.isMaximized()
    };

    // 保存到配置文件 (使用 electron-store 或 JSON 文件)
    store.set('windowState', state);
  }

  restoreWindowState(): void {
    const savedState = store.get('windowState');

    if (savedState && this.mainWindow) {
      this.mainWindow.setBounds({
        width: savedState.width,
        height: savedState.height,
        x: savedState.x,
        y: savedState.y
      });

      if (savedState.isMaximized) {
        this.mainWindow.maximize();
      }
    }
  }
}
```

#### 2. FileManager (文件管理器)

```typescript
// platforms/scada/packages/main/src/fileManager.ts

import { dialog, BrowserWindow } from 'electron';
import * as fs from 'fs/promises';
import * as path from 'path';

export class FileManager {
  async openProjectFile(): Promise<{ project: Project } | null> {
    const result = await dialog.showOpenDialog(BrowserWindow.getFocusedWindow()!, {
      title: '打开工程文件',
      filters: [
        { name: 'Scada工程文件', extensions: ['scada', 'json'] },
        { name: '所有文件', extensions: ['*'] }
      ],
      properties: ['openFile']
    });

    if (result.canceled || result.filePaths.length === 0) {
      return null;
    }

    const filePath = result.filePaths[0];

    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const project = JSON.parse(content);

      // 添加文件路径到工程对象
      project.filePath = filePath;

      return { project };
    } catch (error) {
      throw new Error(`无法打开文件: ${error.message}`);
    }
  }

  async saveProjectFile(project: Project, filePath: string): Promise<boolean> {
    try {
      // 移除 filePath 字段，不保存到文件中
      const { filePath: _, ...projectToSave } = project as any;

      const content = JSON.stringify(projectToSave, null, 2);
      await fs.writeFile(filePath, content, 'utf-8');

      return true;
    } catch (error) {
      throw new Error(`无法保存文件: ${error.message}`);
    }
  }

  async showSaveFileDialog(defaultName: string): Promise<string | null> {
    const result = await dialog.showSaveDialog(BrowserWindow.getFocusedWindow()!, {
      title: '保存工程文件',
      defaultPath: defaultName,
      filters: [
        { name: 'Scada工程文件', extensions: ['scada'] },
        { name: 'JSON文件', extensions: ['json'] }
      ]
    });

    if (result.canceled || !result.filePath) {
      return null;
    }

    return result.filePath;
  }
}
```

#### 3. MenuManager (菜单管理器)

```typescript
// platforms/scada/packages/main/src/menuManager.ts

import { Menu, MenuItem, BrowserWindow } from 'electron';

export class MenuManager {
  createApplicationMenu(): Menu {
    const template = [
      {
        label: '文件',
        submenu: [
          {
            label: '新建工程',
            accelerator: 'CmdOrCtrl+N',
            click: () => this.sendCommandToRenderer('project:new')
          },
          {
            label: '打开工程...',
            accelerator: 'CmdOrCtrl+O',
            click: () => this.sendCommandToRenderer('project:open')
          },
          { type: 'separator' },
          {
            label: '保存',
            accelerator: 'CmdOrCtrl+S',
            click: () => this.sendCommandToRenderer('project:save')
          },
          {
            label: '另存为...',
            accelerator: 'CmdOrCtrl+Shift+S',
            click: () => this.sendCommandToRenderer('project:save-as')
          },
          { type: 'separator' },
          {
            label: '最近打开',
            submenu: this.createRecentFilesMenu()
          },
          { type: 'separator' },
          { role: 'quit', label: '退出' }
        ]
      },
      {
        label: '编辑',
        submenu: [
          { role: 'undo', label: '撤销' },
          { role: 'redo', label: '重做' },
          { type: 'separator' },
          { role: 'cut', label: '剪切' },
          { role: 'copy', label: '复制' },
          { role: 'paste', label: '粘贴' },
          { role: 'delete', label: '删除' },
          { type: 'separator' },
          { role: 'selectAll', label: '全选' }
        ]
      },
      {
        label: '视图',
        submenu: [
          {
            label: '放大',
            accelerator: 'CmdOrCtrl+Plus',
            click: () => this.sendCommandToRenderer('view:zoom-in')
          },
          {
            label: '缩小',
            accelerator: 'CmdOrCtrl+-',
            click: () => this.sendCommandToRenderer('view:zoom-out')
          },
          {
            label: '适应窗口',
            accelerator: 'CmdOrCtrl+0',
            click: () => this.sendCommandToRenderer('view:fit-to-window')
          },
          { type: 'separator' },
          {
            label: '显示/隐藏左侧面板',
            accelerator: 'CmdOrCtrl+Shift+L',
            click: () => this.sendCommandToRenderer('view:toggle-left-sidebar')
          },
          {
            label: '显示/隐藏右侧面板',
            accelerator: 'CmdOrCtrl+Shift+R',
            click: () => this.sendCommandToRenderer('view:toggle-right-panel')
          }
        ]
      },
      {
        label: '工具',
        submenu: [
          {
            label: '组件库...',
            click: () => this.sendCommandToRenderer('tools:component-library')
          },
          {
            label: '设置...',
            click: () => this.sendCommandToRenderer('tools:settings')
          }
        ]
      },
      {
        label: '帮助',
        submenu: [
          {
            label: '文档',
            click: () => { /* 打开在线文档 */ }
          },
          {
            label: '关于',
            click: () => { /* 显示关于对话框 */ }
          }
        ]
      }
    ];

    return Menu.buildFromTemplate(template);
  }

  private sendCommandToRenderer(command: string): void {
    const focusedWindow = BrowserWindow.getFocusedWindow();
    if (focusedWindow) {
      focusedWindow.webContents.send('menu-command', command);
    }
  }

  private createRecentFilesMenu(): MenuItem[] {
    // 从配置文件读取最近文件列表
    const recentFiles = store.get('recentFiles', []) as RecentFile[];

    return recentFiles.map(file => ({
      label: file.projectName,
      click: () => this.sendCommandToRenderer('project:open-recent', { filePath: file.filePath })
    }));
  }
}
```

#### 4. NotificationManager (通知管理器)

```typescript
// platforms/scada/packages/main/src/notificationManager.ts

import { Notification } from 'electron';

export class NotificationManager {
  showNotification(options: {
    title: string;
    message: string;
    type: 'info' | 'success' | 'warning' | 'error';
  }): boolean {
    const { title, message, type } = options;

    // 使用 Electron 原生通知
    const notification = new Notification({
      title,
      body: message,
      icon: this.getIconForType(type),
      urgency: this.getUrgencyForType(type)
    });

    notification.show();

    return true;
  }

  private getIconForType(type: string): string {
    // 返回不同类型通知的图标路径
    const iconMap = {
      success: path.join(__dirname, 'icons/success.png'),
      error: path.join(__dirname, 'icons/error.png'),
      warning: path.join(__dirname, 'icons/warning.png'),
      info: path.join(__dirname, 'icons/info.png')
    };

    return iconMap[type] || iconMap.info;
  }

  private getUrgencyForType(type: string): 'normal' | 'critical' | 'low' {
    const urgencyMap = {
      error: 'critical',
      warning: 'normal',
      success: 'low',
      info: 'low'
    };

    return urgencyMap[type] || 'low';
  }
}
```

#### 5. AutoSaveManager (自动保存管理器)

```typescript
// platforms/scada/packages/main/src/autoSaveManager.ts

export class AutoSaveManager {
  private autoSaveInterval: NodeJS.Timeout | null = null;
  private autoSaveEnabled = true;
  private readonly AUTO_SAVE_INTERVAL = 5 * 60 * 1000; // 5分钟

  startAutoSave(mainWindow: BrowserWindow): void {
    if (this.autoSaveInterval) {
      this.stopAutoSave();
    }

    this.autoSaveInterval = setInterval(() => {
      if (this.autoSaveEnabled) {
        // 通知 Renderer Process 执行自动保存
        mainWindow.webContents.send('project:autosave');
      }
    }, this.AUTO_SAVE_INTERVAL);
  }

  stopAutoSave(): void {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
  }

  setAutoSaveEnabled(enabled: boolean): void {
    this.autoSaveEnabled = enabled;
  }
}
```

### 主进程 IPC 注册

```typescript
// platforms/scada/packages/main/src/index.ts (主进程入口)

import { app, BrowserWindow, ipcMain } from 'electron';
import { WindowManager } from './windowManager';
import { FileManager } from './fileManager';
import { MenuManager } from './menuManager';
import { NotificationManager } from './notificationManager';
import { AutoSaveManager } from './autoSaveManager';

let mainWindow: BrowserWindow;
const windowManager = new WindowManager();
const fileManager = new FileManager();
const menuManager = new MenuManager();
const notificationManager = new NotificationManager();
const autoSaveManager = new AutoSaveManager();

app.whenReady().then(() => {
  mainWindow = windowManager.createMainWindow();
  windowManager.restoreWindowState();

  // 设置应用菜单
  Menu.setApplicationMenu(menuManager.createApplicationMenu());

  // 启动自动保存
  autoSaveManager.startAutoSave(mainWindow);

  // 注册 IPC 处理器
  registerIPCHandlers();
});

function registerIPCHandlers(): void {
  // 工程文件操作
  ipcMain.handle('project:open', async () => {
    return await fileManager.openProjectFile();
  });

  ipcMain.handle('project:save', async (event, { project, filePath }) => {
    return await fileManager.saveProjectFile(project, filePath);
  });

  ipcMain.handle('project:save-as', async (event, { project, filePath }) => {
    return await fileManager.saveProjectFile(project, filePath);
  });

  // 文件对话框
  ipcMain.handle('dialog:open-file', async (event, { filters }) => {
    const result = await dialog.showOpenDialog(mainWindow, {
      filters,
      properties: ['openFile']
    });
    return { filePath: result.canceled ? null : result.filePaths[0] };
  });

  ipcMain.handle('dialog:save-file', async (event, { filters, defaultPath }) => {
    const result = await dialog.showSaveDialog(mainWindow, {
      filters,
      defaultPath
    });
    return { filePath: result.canceled ? null : result.filePath };
  });

  // 窗口状态
  ipcMain.handle('window:get-state', () => {
    return windowManager.getWindowState();
  });

  ipcMain.handle('window:set-state', (event, state) => {
    return windowManager.setWindowState(state);
  });

  // 最近文件
  ipcMain.handle('recent-files:get', () => {
    return { files: store.get('recentFiles', []) };
  });

  ipcMain.handle('recent-files:add', (event, { filePath, projectName }) => {
    const recentFiles = store.get('recentFiles', []) as RecentFile[];
    const newFile: RecentFile = {
      filePath,
      projectName,
      openedAt: Date.now()
    };

    // 添加到开头，移除重复项
    const filtered = recentFiles.filter(f => f.filePath !== filePath);
    store.set('recentFiles', [newFile, ...filtered].slice(0, 10));

    return { success: true };
  });

  // 系统通知
  ipcMain.handle('notification:show', (event, { title, message, type }) => {
    return notificationManager.showNotification({ title, message, type });
  });
}
```

### Preload 脚本 (类型安全)

```typescript
// platforms/scada/packages/main/preload/index.ts

import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  // 工程操作
  openProject: () => ipcRenderer.invoke('project:open'),
  saveProject: (project: Project, filePath: string) =>
    ipcRenderer.invoke('project:save', { project, filePath }),
  saveProjectAs: (project: Project, filePath: string) =>
    ipcRenderer.invoke('project:save-as', { project, filePath }),

  // 文件对话框
  openFileDialog: (filters: FileFilter[]) =>
    ipcRenderer.invoke('dialog:open-file', { filters }),
  saveFileDialog: (filters: FileFilter[], defaultPath: string) =>
    ipcRenderer.invoke('dialog:save-file', { filters, defaultPath }),

  // 窗口状态
  getWindowState: () => ipcRenderer.invoke('window:get-state'),
  setWindowState: (state: WindowState) =>
    ipcRenderer.invoke('window:set-state', state),

  // 最近文件
  getRecentFiles: () => ipcRenderer.invoke('recent-files:get'),
  addRecentFile: (filePath: string, projectName: string) =>
    ipcRenderer.invoke('recent-files:add', { filePath, projectName }),

  // 系统通知
  showNotification: (title: string, message: string, type: string) =>
    ipcRenderer.invoke('notification:show', { title, message, type }),

  // 事件监听
  onMenuCommand: (callback: (command: string) => void) => {
    ipcRenderer.on('menu-command', (event, command) => callback(command));
  },
  onAutoSave: (callback: (project: Project) => void) => {
    ipcRenderer.on('project:autosave', (event, project) => callback(project));
  }
});

// TypeScript 类型定义
export interface ElectronAPI {
  openProject: () => Promise<{ project: Project } | null>;
  saveProject: (project: Project, filePath: string) => Promise<{ success: boolean }>;
  saveProjectAs: (project: Project, filePath: string) => Promise<{ success: boolean }>;
  openFileDialog: (filters: FileFilter[]) => Promise<{ filePath: string | null }>;
  saveFileDialog: (filters: FileFilter[], defaultPath: string) => Promise<{ filePath: string | null }>;
  getWindowState: () => Promise<WindowState>;
  setWindowState: (state: WindowState) => Promise<{ success: boolean }>;
  getRecentFiles: () => Promise<{ files: RecentFile[] }>;
  addRecentFile: (filePath: string, projectName: string) => Promise<{ success: boolean }>;
  showNotification: (title: string, message: string, type: string) => Promise<{ success: boolean }>;
  onMenuCommand: (callback: (command: string) => void) => void;
  onAutoSave: (callback: (project: Project) => void) => void;
}

declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}
```

### 系统架构图 (包含 Electron)

```
┌─────────────────────────────────────────────────────────────────┐
│                      Scada Electron Application                 │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Main Process (Node.js Runtime)                         │   │
│  │  - WindowManager (窗口管理)                             │   │
│  │  - FileManager (文件操作)                               │   │
│  │  - MenuManager (菜单管理)                               │   │
│  │  - ShortcutManager (快捷键管理)                         │   │
│  │  - NotificationManager (通知管理)                       │   │
│  │  - AutoSaveManager (自动保存)                           │   │
│  │  - IPC Handlers (进程间通信)                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↕ IPC                              │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Renderer Process (React UI)                            │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │  TitleBar (FE-005)                              │    │   │
│  │  │  - Logo + Title                                 │    │   │
│  │  │  - ProjectTabs ← NEW (FE-006-01)                │    │   │
│  │  │  - WindowControls                               │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │

```
┌─────────────────────────────────────────────────────────────────┐
│                        Scada Application                       │
│  (TitleBar + Sidebar + MainContent - 已实现: FE-001, FE-005)    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Editor Layout (新增)                        │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Top Toolbar (32px)                                      │   │
│  │  文件操作 | 编辑工具 | 视图控制 | 工具箱                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Sub Toolbar (64px) - 上下文相关工具                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌──────────┬─────────────────────────────┬─────────────────┐   │
│  │          │  Sub-Page Tabs (36px)       │                 │   │
│  │  Left    ├─────────────────────────────┤  Right Panel    │   │
│  │ Sidebar  │                             │  (280px)        │   │
│  │ (280px)  │     Canvas Area              │  - Properties  │   │
│  │          │                             │  - Layers      │   │
│  │ - 工程   │                             │                 │   │
│  │ - 画面   │                             │  (默认隐藏)     │   │
│  │ - 组件   │                             │                 │   │
│  └──────────┴─────────────────────────────┴─────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Status Bar (24px)                                        │   │
│  │  状态 | 缩放 | 坐标 | 通知                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    MobX Store Architecture                       │
├─────────────────────────────────────────────────────────────────┤
│  editorStore: {                                                  │
│    projectTabs: ProjectTab[],        // 工程标签页列表          │
│    activeProjectTab: string,         // 当前活动标签页ID        │
│    leftSidebarActiveTab: '工程' | '画面' | '组件',           │
│    rightPanelVisible: boolean,        // 右侧属性栏可见性        │
│    rightPanelActiveTab: '属性' | '图层',                     │
│    selectedObject: string | null,     // 当前选中对象ID         │
│    zoom: number,                     // 画布缩放比例            │
│  }                                                               │
│                                                                  │
│  projectStore: {                                                 │
│    currentProject: Project,           // 当前工程数据            │
│    pages: Page[],                    // 工程画面列表            │
│    components: Component[],           // 组件库列表              │
│  }                                                               │
│                                                                  │
│  canvasStore: {                                                  │
│    currentPage: Page,                // 当前页面                │
│    canvasObjects: CanvasObject[],     // 画布对象列表            │
│    selectedObjectIds: string[],       // 选中的对象ID列表        │
│  }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 组件设计

| 组件名 | 职责 | 依赖 | 接口 | 技术栈 |
|--------|------|------|------|--------|
| **EditorLayout** | 六区域布局容器，管理编辑器整体布局 | editorStore | - children: ReactNode | React + Flexbox |
| **TopToolbar** | 顶部工具导航栏，显示常用操作按钮 | editorStore | - onAction(action: string): void | React + Button组件 |
| **SubToolbar** | 子工具栏，显示上下文相关的快捷操作 | canvasStore | - selectedObject: CanvasObject | React + Form组件 |
| **LeftSidebar** | 左侧导航栏容器，管理3个Tab | editorStore | - activeTab: string<br>- onTabChange(tab: string): void | React + Tab组件 |
| **RightPanel** | 右侧属性栏容器，管理2个Tab | editorStore | - visible: boolean<br>- activeTab: string<br>- onTabChange(tab: string): void | React + Tab组件 |
| **ProjectPanel** | 工程面板，显示工程树形结构 | projectStore | - project: Project<br>- onSelect(nodeId: string): void | React + Tree组件 |
| **PagesPanel** | 画面面板，显示工程画面列表 | projectStore | - pages: Page[]<br>- onSelect(pageId: string): void | React + List组件 |
| **ComponentsPanel** | 组件面板，显示可拖拽组件库 | projectStore | - components: Component[]<br>- onDragStart(component: Component): void | React + Grid组件 |
| **PropertiesPanel** | 属性面板，编辑选中对象属性 | canvasStore | - selectedObjects: CanvasObject[]<br>- onPropertyChange(id: string, prop: string, value: any): void | React + Form组件 |
| **LayersPanel** | 图层面板，管理图层顺序 | canvasStore | - layers: Layer[]<br>- onReorder(layers: Layer[]): void | React + List组件 |
| **SubPageTabs** | 子页面标签栏，管理多个页面标签 | projectStore | - pages: Page[]<br>- activePageId: string<br>- onSelect(pageId: string): void | React + Tab组件 |
| **CanvasArea** | 画布区域，显示编辑内容 | canvasStore | - page: Page<br>- objects: CanvasObject[]<br>- onSelect(ids: string[]): void | React + Canvas/DOM |
| **StatusBar** | 底部状态栏，显示状态信息 | editorStore, canvasStore | - zoom: number<br>- mousePosition: {x, y}<br>- onZoomChange(zoom: number): void | React + 组件化 |
| **ProjectTab** | 工程标签页，显示在TitleBar中 | editorStore | - project: Project<br>- isActive: boolean<br>- onClose(): void | React + Tab样式 |

### 组件层次结构

```
EditorLayout
├── TopToolbar
│   ├── ToolbarGroup (文件操作)
│   │   └── ToolbarButton[]
│   ├── ToolbarGroup (编辑操作)
│   │   └── ToolbarButton[]
│   ├── ToolbarGroup (视图操作)
│   │   └── ToolbarButton[]
│   └── ToolbarGroup (工具箱)
│       └── ToolbarButton[]
├── SubToolbar
│   └── ContextualControls (根据选中对象动态渲染)
├── LeftSidebar
│   ├── SidebarTab ('工程' | '画面' | '组件')
│   ├── ProjectPanel (当activeTab='工程')
│   ├── PagesPanel (当activeTab='画面')
│   └── ComponentsPanel (当activeTab='组件')
├── SubPageTabs
│   └── SubPageTab[]
├── CanvasArea
│   └── Canvas
│       └── CanvasObject[] (组件实例)
├── RightPanel
│   ├── SidebarTab ('属性' | '图层')
│   ├── PropertiesPanel (当activeTab='属性')
│   └── LayersPanel (当activeTab='图层')
└── StatusBar
    ├── StatusInfo
    ├── ZoomControls
    ├── CoordinateInfo
    └── Notifications
```

### 数据流

```
┌─────────────┐
│   User      │  点击、拖拽、输入等用户操作
└──────┬──────┘
       │
       ↓
┌─────────────┐
│  UI组件     │  触发事件回调
└──────┬──────┘
       │
       ↓
┌─────────────┐
│  MobX Store │  更新状态 (editorStore/projectStore/canvasStore)
└──────┬──────┘
       │
       ↓
┌─────────────┐
│  响应式更新  │  组件自动重新渲染
└─────────────┘

数据流示例：
1. 用户点击左侧导航栏"工程"Tab
2. LeftSidebar触发 onTabChange('工程')
3. editorStore.setLeftSidebarActiveTab('工程')
4. LeftSidebar重新渲染，显示ProjectPanel
5. 其他组件保持不变（MobX精确响应）

数据流示例2：
1. 用户在画布中选中一个矩形组件
2. Canvas触发 onSelect(['rect-001'])
3. canvasStore.setSelectedObjectIds(['rect-001'])
4. editorStore.setSelectedObject('rect-001')
5. editorStore.setRightPanelVisible(true)
6. RightPanel从隐藏变为显示
7. PropertiesPanel显示rect-001的属性
```

## 接口设计

### 组件接口

#### EditorLayout Props

```typescript
interface EditorLayoutProps {
  // 工程标签页列表
  projectTabs: ProjectTab[];
  // 当前活动标签页ID
  activeProjectTabId: string;
  // 当前工程数据
  currentProject: Project | null;
}
```

#### LeftSidebar Props

```typescript
interface LeftSidebarProps {
  // 当前激活的Tab
  activeTab: '工程' | '画面' | '组件';
  // Tab切换回调
  onTabChange: (tab: '工程' | '画面' | '组件') => void;
  // 工程数据
  project: Project | null;
  // 画面列表
  pages: Page[];
  // 组件库
  components: Component[];
  // 选中对象回调（用于显示右侧属性栏）
  onSelectObject: (objectId: string) => void;
}
```

#### RightPanel Props

```typescript
interface RightPanelProps {
  // 是否可见
  visible: boolean;
  // 当前激活的Tab
  activeTab: '属性' | '图层';
  // Tab切换回调
  onTabChange: (tab: '属性' | '图层') => void;
  // 选中的对象
  selectedObjects: CanvasObject[];
  // 属性变更回调
  onPropertyChange: (objectId: string, property: string, value: any) => void;
  // 图层重排序回调
  onLayerReorder: (layers: Layer[]) => void;
}
```

### Store接口

#### editorStore

```typescript
interface EditorStore {
  // 状态
  projectTabs: ObservableArray<ProjectTab>;
  activeProjectTabId: string;
  leftSidebarActiveTab: '工程' | '画面' | '组件';
  rightPanelVisible: boolean;
  rightPanelActiveTab: '属性' | '图层';
  selectedObjectIds: ObservableArray<string>;
  zoom: number;

  // 操作
  openProject(project: Project): void;
  closeProject(projectId: string): void;
  switchProject(projectId: string): void;
  setLeftSidebarActiveTab(tab: '工程' | '画面' | '组件'): void;
  setRightPanelVisible(visible: boolean): void;
  setRightPanelActiveTab(tab: '属性' | '图层'): void;
  setSelectedObjects(ids: string[]): void;
  setZoom(zoom: number): void;
}
```

#### projectStore

```typescript
interface ProjectStore {
  // 状态
  currentProject: Project | null;
  pages: ObservableArray<Page>;
  components: ObservableArray<Component>;

  // 操作
  createProject(name: string): Project;
  openProject(file: File): Promise<Project>;
  saveProject(): Promise<void>;
  createPage(name: string): Page;
  deletePage(pageId: string): void;
  renamePage(pageId: string, newName: string): void;
  getComponentLibrary(): Component[];
}
```

#### canvasStore

```typescript
interface CanvasStore {
  // 状态
  currentPageId: string | null;
  canvasObjects: ObservableArray<CanvasObject>;
  selectedObjectIds: ObservableArray<string>;

  // 操作
  setCurrentPage(pageId: string): void;
  addComponent(component: Component, position: {x, y}): CanvasObject;
  deleteObjects(ids: string[]): void;
  selectObjects(ids: string[]): void;
  updateObjectProperty(id: string, property: string, value: any): void;
  reorderLayers(ids: string[]): void;
}
```

### 数据模型

#### ProjectTab

```typescript
interface ProjectTab {
  id: string;              // 唯一标识
  projectId: string;       // 关联的工程ID
  title: string;           // 显示标题（工程名称）
  icon: string;            // 图标（SVG路径）
  isDirty: boolean;        // 是否有未保存修改
  isActive: boolean;       // 是否为活动标签
}
```

| 字段名 | 类型 | 必填 | 说明 | 约束 |
|--------|------|------|------|------|
| id | string | 是 | 标签页唯一标识 | UUID格式 |
| projectId | string | 是 | 关联的工程ID | 外键 |
| title | string | 是 | 显示标题 | 最长50字符 |
| icon | string | 是 | 图标SVG路径 | 有效SVG路径 |
| isDirty | boolean | 是 | 未保存标识 | 默认false |
| isActive | boolean | 是 | 是否活动 | 默认false |

#### Project (工程)

```typescript
interface Project {
  id: string;
  name: string;
  description: string;
  createdAt: Date;
  updatedAt: Date;
  pages: Page[];
  settings: ProjectSettings;
}
```

#### Page (画面/页面)

```typescript
interface Page {
  id: string;
  projectId: string;
  name: string;
  canvasWidth: number;
  canvasHeight: number;
  backgroundColor: string;
  objects: CanvasObject[];
  layers: Layer[];
}
```

#### CanvasObject (画布对象)

```typescript
interface CanvasObject {
  id: string;
  pageId: string;
  type: 'rectangle' | 'circle' | 'text' | 'image' | 'button' | 'switch' | ...;
  name: string;
  x: number;
  y: number;
  width: number;
  height: number;
  visible: boolean;
  locked: boolean;
  style: ObjectStyle;
  dataBinding?: DataBinding;
  events?: EventHandler[];
}

interface ObjectStyle {
  backgroundColor?: string;
  borderColor?: string;
  borderWidth?: number;
  borderStyle?: 'solid' | 'dashed' | 'dotted';
  opacity?: number;
  fontSize?: number;
  fontFamily?: string;
  color?: string;
  // ... 更多样式属性
}
```

#### Component (组件定义)

```typescript
interface Component {
  id: string;
  category: 'basic' | 'input' | 'chart' | 'advanced';
  name: string;
  icon: string;
  defaultSize: { width: number; height: number };
  defaultStyle: ObjectStyle;
  editableProperties: string[];
}
```

#### Layer (图层)

```typescript
interface Layer {
  objectId: string;
  objectName: string;
  visible: boolean;
  locked: boolean;
  z-index: number;
}
```

## 实施计划

### 阶段1: 基础布局和状态管理 (P0)

**目标**: 实现六区域布局和MobX状态管理架构

- [ ] **FE-006-02**: 创建EditorLayout组件，实现六区域Flexbox布局
- [ ] **FE-006-15**: 创建MobX Store架构（editorStore/projectStore/canvasStore）
- [ ] **FE-006-16**: 扩展CSS变量系统，添加编辑器专用样式变量
- [ ] **FE-006-14**: 创建StatusBar组件，显示基础状态信息
- [ ] 集成EditorLayout到MainContent，替换占位内容

**预估**: 2-3天

### 阶段2: 工程标签页和导航栏 (P0)

**目标**: 实现工程标签页管理和左侧导航栏

- [ ] **FE-006-01**: 创建ProjectTab组件，集成到TitleBar
- [ ] **FE-006-05**: 创建LeftSidebar容器和SidebarTab组件
- [ ] **FE-006-06**: 创建ProjectPanel组件（工程树形结构）
- [ ] **FE-006-07**: 创建PagesPanel组件（画面列表）
- [ ] **FE-006-08**: 创建ComponentsPanel组件（组件库）
- [ ] 实现Tab切换逻辑和状态同步

**预估**: 2-3天

### 阶段3: 工具栏和画布区域 (P0)

**目标**: 实现顶部工具栏、子工具栏和画布区域

- [ ] **FE-006-03**: 创建TopToolbar组件和ToolbarButton组件
- [ ] **FE-006-04**: 创建SubToolbar组件（上下文相关工具）
- [ ] **FE-006-12**: 创建SubPageTabs组件（子页面标签栏）
- [ ] **FE-006-13**: 创建CanvasArea组件和Canvas组件
- [ ] 实现工具栏按钮的Mock点击事件
- [ ] 实现画布的网格背景和占位内容

**预估**: 2-3天

### 阶段4: 右侧属性栏 (P0)

**目标**: 实现右侧属性栏、属性面板和图层面板

- [ ] **FE-006-09**: 创建RightPanel容器和Tab切换逻辑
- [ ] **FE-006-10**: 创建PropertiesPanel组件（属性编辑）
- [ ] **FE-006-11**: 创建LayersPanel组件（图层管理）
- [ ] 实现选中对象时显示右侧属性栏
- [ ] 实现属性编辑的Mock功能
- [ ] 实现图层重排序的Mock功能

**预估**: 2天

### 阶段5: Electron 主进程集成 (P0)

**目标**: 实现 Electron 主进程功能，打通前后端通信

- [ ] **Main-001**: 创建 WindowManager，实现窗口创建和状态持久化
- [ ] **Main-002**: 创建 FileManager，实现文件打开/保存功能
- [ ] **Main-003**: 创建 MenuManager，实现应用菜单和快捷键
- [ ] **Main-004**: 创建 NotificationManager，实现系统通知
- [ ] **Main-005**: 创建 AutoSaveManager，实现自动保存功能
- [ ] **Main-006**: 注册所有 IPC Handlers
- [ ] **Main-007**: 创建 Preload 脚本，暴露类型安全的 API
- [ ] **FE-006-集成**: 在前端 MobX Store 中集成 IPC 调用
- [ ] **FE-006-集成**: 实现工具栏按钮的真实文件操作功能
- [ ] **FE-006-集成**: 实现菜单命令监听和响应
- [ ] **FE-006-集成**: 实现最近文件列表显示和打开
- [ ] 测试 IPC 通信的完整流程

**预估**: 3-4天

### 阶段6: 集成和优化 (P1)

**目标**: 集成所有组件（前端+后端），优化交互和样式

- [ ] 集成所有前端组件到EditorLayout
- [ ] 集成 Electron 主进程功能
- [ ] 实现组件间状态同步
- [ ] 实现前后端状态同步（MobX ↔ Main Process）
- [ ] 优化样式，遵循STYLE_GUIDE.md
- [ ] 添加悬停效果和过渡动画
- [ ] 实现响应式布局（窗口缩放）
- [ ] 性能优化（React.memo、useMemo）
- [ ] 窗口状态持久化测试
- [ ] 文件操作边界情况测试

**预估**: 2-3天

**总计预估**: 13-20天
- 阶段1: 2-3天（前端布局和状态管理）
- 阶段2: 2-3天（前端标签页和导航栏）
- 阶段3: 2-3天（前端工具栏和画布）
- 阶段4: 2天（前端属性栏）
- 阶段5: 3-4天（Electron 主进程）
- 阶段6: 2-3天（集成和优化）

## 风险和挑战

| 风险 | 影响 | 概率 | 缓解措施 | 责任人 |
|------|------|------|---------|--------|
| **组件数量多，开发周期长** | 高 | 中 | 优先实现P0功能，P1功能分阶段开发；使用组件库加速开发 | 开发团队 |
| **MobX状态管理复杂度高** | 中 | 中 | 设计清晰的Store结构；编写详细的Store文档；编写单元测试 | 开发团队 |
| **右侧属性栏动态显示可能导致布局跳动** | 中 | 中 | 使用CSS transition实现平滑动画；预留固定空间避免布局重排 | 开发团队 |
| **16个子组件的样式一致性难以保证** | 中 | 中 | 严格遵循STYLE_GUIDE.md；使用CSS Variables统一管理样式；建立样式Review机制 | 开发团队 |
| **性能问题：组件渲染慢** | 中 | 低 | 使用React.memo优化重渲染；使用虚拟滚动（如需要）；MobX精确响应 | 开发团队 |
| **与现有FE-001的集成可能冲突** | 低 | 低 | EditorLayout作为独立模块，通过Props集成；保持CSS命名空间隔离 | 开发团队 |
| **Electron IPC通信调试困难** | 中 | 中 | 使用Electron DevTools；编写详细的IPC文档；建立完善的错误处理和日志记录 | 开发团队 |
| **文件操作边界情况多（权限、路径、编码）** | 中 | 中 | 编写完整的单元测试覆盖边界情况；提供友好的错误提示；实现文件备份机制 | 开发团队 |
| **跨平台兼容性（Windows/macOS/Linux）** | 中 | 中 | 使用Electron API的跨平台封装；在三大平台进行测试；处理平台特定差异 | 开发团队 |
| **窗口状态持久化可能失效** | 低 | 低 | 使用electron-store保证可靠性；实现降级方案（默认窗口状态）；添加版本迁移逻辑 | 开发团队 |

## 影响分析

### 影响范围
- **前端模块**:
  - `platforms/scada/packages/renderer/src/components/layout/` (新增editor子目录)
  - `platforms/scada/packages/renderer/src/components/editor/` (新增14个UI组件)
  - `platforms/scada/packages/renderer/src/store/` (新增editorStore/projectStore/canvasStore)
  - `platforms/scada/packages/renderer/src/styles/` (新增editor.css)
  - `platforms/scada/packages/renderer/src/types/` (新增编辑器类型定义)
- **主进程模块**:
  - `platforms/scada/packages/main/src/windowManager.ts` (窗口管理)
  - `platforms/scada/packages/main/src/fileManager.ts` (文件操作)
  - `platforms/scada/packages/main/src/menuManager.ts` (菜单管理)
  - `platforms/scada/packages/main/src/notificationManager.ts` (通知管理)
  - `platforms/scada/packages/main/src/autoSaveManager.ts` (自动保存)
  - `platforms/scada/packages/main/src/index.ts` (IPC注册)
  - `platforms/scada/packages/main/preload/index.ts` (Preload脚本)
- **系统**: Scada桌面应用（Electron + React）
- **功能**: FE-006 (新增)，FE-001 (扩展集成)，FE-005 (扩展集成)

### 兼容性
- **向后兼容**: 是，EditorLayout作为独立模块，不影响现有FE-001、FE-005功能
- **数据兼容**: 是，初始使用Mock数据，后续接入真实工程文件格式
- **平台兼容**: 需支持Windows、macOS、Linux三大平台
- **Electron版本**: 项目已使用Electron，本方案基于现有版本扩展

### 迁移策略
- **阶段1**: 前端UI组件开发和集成
  - EditorLayout开发完成并测试后，集成到MainContent
  - 逐步替换MainContent中的占位符为真实组件
  - 工程标签页集成到TitleBar，确保Tab切换正常
- **阶段2**: Electron主进程开发和集成
  - 逐步添加主进程功能模块（WindowManager, FileManager等）
  - 注册IPC通道，打通前后端通信
  - 创建Preload脚本，暴露类型安全的API
- **阶段3**: 前后端集成和测试
  - 在前端MobX Store中集成IPC调用
  - 替换Mock数据为真实文件操作
  - 实现菜单命令监听和响应
  - 实现最近文件列表显示和打开
- **回滚策略**:
  - 前端：保留原有MainContent，通过配置开关切换
  - 后端：IPC调用失败时降级到Mock实现，保证UI可用

## 架构决策记录 (ADR)

### 决策1: 采用六区域布局而非五区域布局

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 需要提供专业的工程编辑界面，参考WPS、Visio等专业软件的布局
- **决策**: 采用六区域布局（工具栏、子工具栏、左侧导航栏、画布、右侧属性栏、状态栏），而非传统的五区域布局
- **后果**:
  - **正面**:
    - 左侧专注于导航（工程、画面、组件）
    - 右侧专注于编辑（属性、图层）
    - 功能分区更清晰，符合工业软件操作习惯
    - 右侧属性栏可隐藏，最大化画布空间
  - **负面**:
    - 布局更复杂，需要管理动态显示/隐藏
    - 需要额外的状态管理逻辑
  - **缓解措施**: 使用MobX统一管理右侧属性栏的可见性；使用CSS transition实现平滑动画

### 决策2: 左侧导航栏采用3个Tab而非5个Tab

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 需要在左侧导航栏显示工程结构、画面列表和组件库
- **决策**: 采用3个Tab（工程、画面、组件），而非原来的5个Tab（项目、组件、属性、图层、数据）
- **后果**:
  - **正面**:
    - Tab数量减少，界面更简洁
    - 属性和图层移至右侧，编辑时更方便
    - 符合主流工程软件（如VS Code）的操作习惯
  - **负面**:
    - 属性和图层不在左侧，可能需要用户适应
    - 需要额外的右侧属性栏组件
  - **缓解措施**: 右侧属性栏默认显示在选中对象时，减少用户操作步骤

### 决策3: 右侧属性栏默认隐藏，选中对象时显示

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 需要在画布足够大的同时提供属性编辑功能
- **决策**: 右侧属性栏默认隐藏，仅在选中编辑对象时显示
- **后果**:
  - **正面**:
    - 最大化画布空间，提升编辑体验
    - 减少视觉干扰，用户专注画布内容
    - 屏幕较小的设备也能良好使用
  - **负面**:
    - 用户需要学习"选中对象→显示属性"的交互模式
    - 可能需要额外的鼠标点击
  - **缓解措施**:
    - 提供快捷键（如Space键）快速切换属性栏
    - 提供清晰的视觉提示（选中高亮）
    - 考虑P2优先级功能：用户可配置属性栏常驻显示

### 决策4: 使用MobX而非Redux进行状态管理

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 项目已使用MobX，需要为编辑器选择状态管理方案
- **决策**: 继续使用MobX，扩展editorStore、projectStore、canvasStore
- **后果**:
  - **正面**:
    - 与现有项目技术栈一致，降低学习成本
    - MobX响应式系统简洁，适合UI状态管理
    - 代码量更少，开发效率更高
  - **负面**:
    - MobX调试工具相对Redux较弱
    - 团队成员可能对MobX不熟悉
  - **缓解措施**:
    - 编写详细的Store文档
    - 建立最佳实践指南
    - 提供MobX开发培训

### 决策5: 组件样式使用Plain CSS而非CSS-in-JS

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 项目已使用Plain CSS + CSS Variables，需要决定组件样式方案
- **决策**: 继续使用Plain CSS + CSS Variables，遵循STYLE_GUIDE.md规范
- **后果**:
  - **正面**:
    - 与现有样式系统一致
    - 样式可全局复用，便于主题定制
    - 不引入额外依赖，打包体积小
    - CSS变量支持动态主题切换
  - **负面**:
    - CSS与组件分离，维护时需要在两个文件间切换
    - 没有样式作用域隔离，可能产生命名冲突
  - **缓解措施**:
    - 使用BEM命名规范避免冲突
    - 建立清晰的文件组织结构
    - 使用CSS Modules的命名约定（如component-name__element）

### 决策6: 顶部工具栏高度32px，子工具栏高度64px

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 需要符合Scada紧凑工业风格，同时容纳足够的工具按钮
- **决策**: 顶部工具栏高度32px（与TitleBar一致），子工具栏高度64px（上下文相关工具需要更多空间）
- **后果**:
  - **正面**:
    - 整体更紧凑，符合工业软件风格
    - 顶部工具栏只放常用操作，避免拥挤
    - 子工具栏有足够空间显示上下文相关的多个控件
  - **负面**:
    - 顶部工具栏高度32px可能限制了按钮数量
    - 两个工具栏总高度96px，占用部分画布空间
  - **缓解措施**:
    - 顶部工具栏只放最常用的操作，其他操作放在菜单或子工具栏
    - 提供工具栏自定义功能（P2优先级）

### 决策7: 使用 Electron IPC 而非 HTTP API 进行前后端通信

- **状态**: 已接受
- **日期**: 2026-01-23
- **上下文**: 桌面应用需要实现文件操作、窗口管理、系统通知等原生功能
- **决策**: 使用 Electron IPC (进程间通信) 而非 HTTP API 进行前后端通信
- **后果**:
  - **正面**:
    - IPC 性能更好，无需网络开销
    - 可以直接使用 Node.js API 访问文件系统
    - 支持双向通信（invoke 和 on）
    - 类型安全的 Preload 脚本可以提供良好的开发体验
    - 不需要启动额外的 HTTP 服务器
  - **负面**:
    - IPC 调试相对复杂，需要特殊的工具
    - 需要手动管理 IPC 通道的命名和版本
    - 跨进程错误处理需要额外注意
  - **缓解措施**:
    - 编写详细的 IPC 通道文档
    - 使用 TypeScript 类型定义确保类型安全
    - 建立统一的错误处理和日志记录机制
    - 使用 Electron DevTools 进行调试

## 性能考虑

### 性能指标

**前端性能**:
- **组件首次渲染时间**: < 100ms
- **状态更新响应时间**: < 16ms (60fps)
- **标签页切换时间**: < 50ms
- **右侧属性栏显示/隐藏**: < 100ms (含动画)
- **内存占用增量**: < 50MB (包含Mock数据)

**IPC 性能**:
- **IPC 调用往返时间**: < 10ms (简单操作)
- **文件打开时间**: < 500ms (中等工程文件)
- **文件保存时间**: < 1000ms (中等工程文件)
- **窗口状态恢复时间**: < 100ms
- **系统通知显示时间**: < 100ms

### 优化策略

1. **组件级优化**:
   - 使用`React.memo`避免不必要的重渲染
   - 使用`useMemo`缓存计算结果
   - 使用`useCallback`缓存回调函数
   - 懒加载组件（如RightPanel）

2. **Store优化**:
   - MobX的`Observable`精确响应，只有访问的observable变化才触发更新
   - 使用`computed`派生状态，避免重复计算
   - 合理设计Store结构，减少不必要的响应关系

3. **样式优化**:
   - 使用CSS Variables，避免重复计算样式
   - 使用`transform`和`opacity`实现动画（GPU加速）
   - 避免强制同步布局（FSL）

4. **资源优化**:
   - SVG图标使用`<symbol>`复用
   - 图标按需加载（只加载当前需要的图标集）
   - Mock数据懒加载（按需生成）

5. **IPC 优化**:
   - 批量 IPC 调用合并，减少通信开销
   - 使用 Buffer 传输大文件，避免序列化开销
   - IPC 通道复用，避免重复创建
   - 异步 IPC 调用避免阻塞 UI

6. **文件操作优化**:
   - 大文件分块读写，避免占用过多内存
   - 使用文件流处理，避免一次性加载整个文件
   - 实现文件缓存机制，避免重复读取
   - 异步文件操作，避免阻塞主进程

## 安全考虑

### 安全威胁

**前端安全**:
- **XSS攻击**: 如果后续支持用户自定义组件名称或属性值，可能导致XSS
- **CSRF攻击**: 如果后续添加远程工程保存功能，需要防范CSRF
- **数据泄露**: 工程文件可能包含敏感信息（如数据库连接字符串）

**Electron 安全**:
- **任意代码执行**: 如果不当使用 nodeIntegration 或 contextIsolation
- **路径遍历攻击**: 文件操作时未正确验证文件路径
- **IPC 注入**: 恶意网站可能尝试通过 preload 脚本注入 IPC 调用
- **特权提升**: 主进程拥有 Node.js 完整权限，需谨慎处理 IPC 请求

### 安全措施

**前端安全**:
- 所有用户输入都通过 React controlled components 管理
- 所有动态内容都经过 React 转义，避免 XSS
- Mock 数据不包含真实敏感信息
- 工程文件加密存储（未来增强）
- 敏感属性（如数据库连接）单独加密（未来增强）
- CSP (Content Security Policy) 头部配置（未来增强）

**Electron 安全**:
- **contextIsolation: true**: 隔离 preload 脚本和页面上下文
- **nodeIntegration: false**: 禁止页面直接访问 Node.js API
- **验证 IPC 请求**: 所有 IPC 调用都需要验证参数和权限
- **沙箱模式**: 主进程运行在受限环境中
- **路径白名单**: 文件操作只允许访问特定目录
- **文件类型验证**: 打开工程文件前验证文件类型和签名
- **IPC 速率限制**: 防止 IPC 滥用导致 DoS
- **日志审计**: 记录所有敏感操作（文件读写、IPC 调用）

## 测试策略

### 单元测试

**前端测试**:
- **覆盖范围**:
  - MobX Store: 所有 actions 和 computed 方法
  - 纯函数组件: 使用 React Testing Library
  - 工具函数: 如格式化、验证函数
- **测试工具**: Vitest + React Testing Library

**主进程测试**:
- **覆盖范围**:
  - WindowManager: 窗口创建、状态保存和恢复
  - FileManager: 文件读取、写入、对话框
  - MenuManager: 菜单创建和命令发送
  - NotificationManager: 通知显示
  - IPC Handlers: 所有 IPC 通道的请求和响应
- **测试工具**: Vitest + Spectron (或 Playwright for Electron)

**示例**:
```typescript
// 前端测试示例
describe('editorStore', () => {
  it('should open new project tab', () => {
    const store = createEditorStore();
    const project = createMockProject();

    store.openProject(project);

    expect(store.projectTabs.length).toBe(1);
    expect(store.projectTabs[0].title).toBe(project.name);
  });

  it('should show right panel when object selected', () => {
    const store = createEditorStore();

    store.setSelectedObjects(['rect-001']);

    expect(store.rightPanelVisible).toBe(true);
  });
});

// 主进程测试示例
describe('FileManager', () => {
  it('should open project file successfully', async () => {
    const fileManager = new FileManager();
    const mockFileContent = JSON.stringify({ id: 'test', name: 'Test Project' });

    // Mock fs.readFile
    vi.mock('fs/promises', () => ({
      readFile: vi.fn().mockResolvedValue(mockFileContent)
    }));

    const result = await fileManager.openProjectFile();

    expect(result).not.toBeNull();
    expect(result.project.name).toBe('Test Project');
  });

  it('should throw error when file not found', async () => {
    const fileManager = new FileManager();

    vi.mock('fs/promises', () => ({
      readFile: vi.fn().mockRejectedValue(new Error('File not found'))
    }));

    await expect(fileManager.openProjectFile()).rejects.toThrow('无法打开文件');
  });
});
```

### 集成测试

**测试场景**:
1. 打开工程 → 验证EditorLayout显示正确
2. 点击左侧Tab → 验证面板切换正确
3. 选中画布对象 → 验证右侧属性栏显示
4. 修改属性 → 验证状态同步到Store
5. 切换标签页 → 验证状态正确恢复
6. **IPC 通信测试**: 验证前端和主进程之间的 IPC 调用正常
7. **文件操作测试**: 验证打开/保存工程文件的完整流程
8. **菜单命令测试**: 验证菜单点击后前端正确响应

**测试工具**: Vitest + React Testing Library + Playwright for Electron

### 视觉回归测试

**测试内容**:
- 组件样式截图对比
- 布局尺寸验证
- 响应式布局验证

**测试工具**: Playwright (可选，P2优先级)

## 变更历史

| 日期 | 版本 | 变更内容 | 变更人 | 评审状态 |
|------|------|---------|--------|---------|
| 2026-01-23 | 1.0 | 初始创建，定义六区域布局架构 | Claude | 待评审 |
| 2026-01-23 | 1.1 | 根据用户反馈调整：左侧3个Tab，右侧2个Tab | Claude | 待评审 |
