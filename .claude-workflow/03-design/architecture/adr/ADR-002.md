# ADR-002: 工程管理架构决策

## 架构决策记录

**决策ID**: ADR-002
**决策标题**: Scada工程管理功能架构决策
**关联方案**: SOL-002
**创建日期**: 2026-01-21
**状态**: ✅ 已批准

---

## 决策1: 工程文件存储格式

### 状态
✅ 已接受

### 上下文
需要选择工程文件的存储格式，考虑以下因素：
- 可读性（调试和手动编辑）
- 文件大小
- 解析性能
- 跨平台兼容性
- 未来扩展性

### 考虑的选项

**选项1: JSON**
- 优点：
  - 人类可读，易于调试
  - 广泛支持，所有平台都有库
  - 易于版本控制（git diff）
  - 支持嵌套数据结构
  - 扩展性好
- 缺点：
  - 文件较大（约1.5倍二进制）
  - 解析速度相对较慢

**选项2: 二进制格式（如MessagePack）**
- 优点：
  - 文件小
  - 解析快
- 缺点：
  - 不可读，难以调试
  - 版本控制困难
  - 库支持较少

**选项3: XML**
- 优点：
  - 人类可读
  - 广泛支持
- 缺点：
  - 冗长，文件大
  - 解析慢
  - 不如JSON流行

### 决策
**选择JSON格式**

理由：
1. 工程文件需要可读性，便于调试和手动修复
2. 文件大小不是主要问题（< 10MB）
3. 解析性能可接受（< 100ms）
4. JSON是行业标准，兼容性最好
5. 便于未来的云端同步和版本控制

### 后果
- 工程文件使用.json扩展名的变体：`.pant`
- 需要实现JSON序列化/反序列化
- 需要实现版本兼容性处理
- 文件大小可能较大，但可接受

---

## 决策2: 工程加密方案

### 状态
✅ 已接受

### 上下文
需要保护工程文件的安全性，防止未授权访问和篡改。

### 考虑的选项

**选项1: AES-256-CBC**
- 优点：
  - 行业标准
  - 广泛支持
- 缺点：
  - 不提供认证，可能被篡改
  - 需要额外的完整性检查

**选项2: AES-256-GCM**
- 优点：
  - 认证加密（AEAD）
  - 防篡改
  - 性能好
  - 现代加密标准
- 缺点：
  - 相对较新（但已广泛采用）

**选项3: ChaCha20-Poly1305**
- 优点：
  - 认证加密
  - 在无AES硬件加速的平台上更快
- 缺点：
  - 支持较少

### 决策
**选择AES-256-GCM**

理由：
1. 认证加密同时提供机密性和完整性
2. 业界推荐，NIST标准
3. Go标准库原生支持
4. 性能优秀（AES-NI指令集加速）

### 后果
- 使用crypto/aes和crypto/cipher包
- 每次加密生成随机nonce
- 使用PBKDF2从密码派生密钥（100,000轮）
- 需要存储HMAC-SHA256签名用于完整性验证
- 加密后文件大小增加约40%（Base64编码）

---

## 决策3: 密码哈希算法

### 状态
✅ 已接受

### 上下文
密码需要安全存储在工程文件中，防止彩虹表攻击。

### 考虑的选项

**选项1: MD5/SHA-1**
- 优点：
  - 速度快
- 缺点：
  - **已不安全**，容易破解
  - 不适合密码存储

**选项2: SHA-256**
- 优点：
  - 安全
- 缺点：
  - 太快，容易被GPU破解
  - 需要加盐（手动实现）

**选项3: bcrypt**
- 优点：
  - 设计用于密码
  - 自动加盐
  - 可调节计算成本
  - 抗GPU破解
- 缺点：
  - 较慢（但这是优点）

**选项4: Argon2**
- 优点：
  - 2015年密码哈希竞赛冠军
  - 抗GPU/ASIC破解
- 缺点：
  - 较新，库支持较少

### 决策
**选择bcrypt（10轮）**

理由：
1. 工业标准，经过时间验证
2. 前端和后端都有成熟库
3. 自动加盐，无需手动管理
4. 10轮在安全性和性能之间平衡（约100ms）
5. 如果未来需要更强安全性，可增加到12轮

### 后果
- 前端使用bcryptjs哈希密码后发送到后端
- 后端验证时比对哈希值
- 哈希操作耗时约100ms，可接受
- 存储在工程文件中的是哈希值，不是明文密码

---

## 决策4: 数据库选择

### 状态
✅ 已接受

### 上下文
需要存储最近工程列表和其他元数据。

### 考虑的选项

**选项1: SQLite**
- 优点：
  - 嵌入式，无需单独服务器
  - 零配置
  - 轻量级（~500KB）
  - 支持SQL
  - 跨平台
- 缺点：
  - 并发写入受限（但本场景够用）

**选项2: JSON文件**
- 优点：
  - 简单
  - 人类可读
- 缺点：
  - 大列表性能差
  - 需要读写整个文件
  - 并发问题

**选项3: IndexedDB（浏览器）**
- 优点：
  - 浏览器内置
- 缺点：
  - 只在浏览器环境可用
  - Electron环境不如SQLite方便

### 决策
**选择SQLite存储最近工程 + localStorage存储分类配置**

理由：
1. SQLite处理50+工程记录性能优秀
2. 支持复杂查询（筛选、排序、分组）
3. Electron环境完美支持
4. 数据独立于工程文件，互不影响
5. localStorage用于简单的用户配置（分类、偏好设置）

### 后果
- 使用gorm或sqlx作为ORM
- 最近工程数据库路径：`~/.pansiot/recent-projects.db`
- 需要实现数据库迁移
- 需要定期清理过期记录（FIFO，保留50个）

---

## 决策5: 前后端通信方式

### 状态
✅ 已接受

### 上下文
Scada是Electron应用，前端和后端需要通信。

### 考虑的选项

**选项1: Electron IPC（主进程通信）**
- 优点：
  - Electron原生
  - 安全
  - 性能好
- 缺点：
  - 需要序列化数据
  - 只能在Electron环境

**选项2: HTTP API（localhost）**
- 优点：
  - 标准RESTful
  - 易于测试（curl、Postman）
  - 未来可分离部署
- 缺点：
  - 需要启动HTTP服务器
  - 略慢于IPC

**选项3: 混合方式**
- IPC用于系统级操作（文件对话框、窗口控制）
- HTTP API用于业务逻辑（工程CRUD）

### 决策
**选择混合方式**

具体分配：
- **Electron IPC**:
  - 文件对话框（打开/保存）
  - 窗口控制
  - 系统信息获取
- **HTTP API** (localhost):
  - 工程CRUD操作
  - 加密/解密
  - 数据库查询
  - 最近工程管理

理由：
1. 分离关注点：系统操作 vs 业务逻辑
2. HTTP API便于独立测试和未来云端集成
3. IPC用于Electron特有功能
4. 开发体验好（可以用Postman测试API）

### 后果
- 后端需要同时实现HTTP服务器和IPC处理器
- 前端需要两套API客户端（fetch和electronAPI）
- 后端监听localhost随机端口
- 需要处理跨进程错误

---

## 决策6: 最近工程列表实现方式

### 状态
✅ 已接受

### 上下文
用户需要快速访问最近打开的工程，需要考虑性能和用户体验。

### 考虑的选项

**选项1: 纯前端（localStorage）**
- 优点：
  - 简单
  - 不需要后端
- 缺点：
  - 5MB限制
  - 性能差（50+条记录）
  - 无法跨设备同步

**选项2: 纯后端（SQLite）**
- 优点：
  - 性能好
  - 支持复杂查询
- 缺点：
  - 每次筛选都要请求后端
  - 网络延迟

**选项3: 混合方式**
- 后端SQLite作为数据源
- 前端MobX缓存数据
- 定期同步

### 决策
**选择混合方式（后端SQLite + 前端MobX缓存）**

实现策略：
1. **初始加载**: 启动时从后端加载最近50个工程
2. **前端缓存**: MobX Store缓存数据，实现即时筛选/搜索
3. **更新同步**: 打开/关闭工程时同步到后端
4. **定期刷新**: 每5分钟刷新一次（可选）

理由：
1. 结合两者优点
2. 前端操作无延迟（筛选、搜索即时响应）
3. 后端数据持久化（跨会话保持）
4. 支持未来云端同步

### 后果
- 需要实现前后端数据同步逻辑
- 需要处理并发更新冲突
- 前端内存占用约50KB（50个工程）
- 需要实现数据过期策略

---

## 决策7: 列表渲染优化方案

### 状态
✅ 已接受

### 上下文
最近工程列表可能包含50+工程，需要优化渲染性能。

### 考虑的选项

**选项1: 原生滚动（全渲染）**
- 优点：
  - 简单
- 缺点：
  - 50+个DOM节点性能差
  - 滚动卡顿

**选项2: 分页加载**
- 优点：
  - 减少DOM节点
- 缺点：
  - 用户体验差
  - 无法全局搜索

**选项3: 虚拟滚动**
- 优点：
  - 只渲染可见项
  - 性能优秀（支持1000+项）
  - 流畅滚动
- 缺点：
  - 实现复杂度高
  - 需要固定项高度

### 决策
**选择虚拟滚动（react-window）**

理由：
1. 性能优秀（50个工程< 1ms渲染）
2. 用户体验流畅
3. 支持无限扩展
4. 项高度固定（80px）适合虚拟滚动
5. react-window库成熟稳定

### 后果
- 使用react-window库
- 列表项高度固定80px
- 需要处理动态高度（如果有）
- 键盘导航需要额外处理

---

## 决策8: 工程分类管理

### 状态
✅ 已接受

### 上下文
用户需要自定义分类来管理工程。

### 考虑的选项

**选项1: 硬编码预设分类**
- 优点：
  - 简单
- 缺点：
  - 不灵活
  - 无法满足所有用户

**选项2: 用户完全自定义**
- 优点：
  - 灵活
- 缺点：
  - 分类名称可能不规范
  - 难以统计

**选项3: 预设 + 自定义混合**
- 提供2-4个常用预设分类
- 允许用户创建自定义分类
- 保存用户创建的分类到配置

### 决策
**选择预设 + 自定义混合方案**

预设分类：
- 分类1
- 分类2

用户可以：
1. 选择预设分类
2. 选择"自定义分类"并输入名称
3. 新创建的分类自动添加到选项列表
4. 分类配置保存到localStorage

理由：
1. 平衡灵活性和规范性
2. 用户友好（有默认选项）
3. 扩展性好
4. 实现简单

### 后果
- 分类数据存储在localStorage
- 需要实现分类管理逻辑
- UI需要支持动态添加分类选项
- 需要处理分类重命名（可选）

---

## 决策9: 搜索实现方式

### 状态
✅ 已接受

### 上下文
用户需要快速搜索工程名称。

### 考虑的选项

**选项1: 前端实时搜索**
- 优点：
  - 无延迟
  - 减轻服务器压力
- 缺点：
  - 只能搜索已加载的数据

**选项2: 后端搜索**
- 优点：
  - 支持全文搜索
  - 可以搜索所有工程
- 缺点：
  - 网络延迟
  - 服务器压力大

**选项3: 模糊搜索（前端）**
- 使用Fuse.js库
- 支持模糊匹配、拼写容错

### 决策
**选择前端实时搜索 + 防抖**

实现：
1. 前端监听搜索框输入
2. 防抖100ms
3. 使用JavaScript字符串匹配（includes）
4. 高亮匹配文字

理由：
1. 最近工程只有50个，前端搜索足够
2. 实时响应，用户体验好
3. 实现简单
4. 性能优秀

### 后果
- 使用MobX computed过滤
- 防抖100ms避免频繁计算
- 高亮匹配文字（CSS + 转义）
- 未来可升级为Fuse.js（模糊搜索）

---

## 决策10: 错误处理策略

### 状态
✅ 已接受

### 上下文
需要统一的错误处理机制，提供友好的用户体验。

### 考虑的选项

**选项1: 直接抛出错误**
- 优点：
  - 简单
- 缺点：
  - 用户体验差
  - 可能崩溃应用

**选项2: 全局错误边界**
- React Error Boundary
- 捕获所有错误
- 显示友好提示

**选项3: 分层错误处理**
- API层：HTTP错误码
- Service层：业务异常
- UI层：友好提示

### 决策
**选择分层错误处理**

层级：
1. **API层**
   - 统一错误码
   - HTTP状态码
   - 错误消息（英文）

2. **Service层**
   - 自定义异常类型
   - 中文错误消息

3. **UI层**
   - Toast/Dialog显示错误
   - 友好的中文提示
   - 建议操作

4. **全局错误边界**
   - 捕获未预期的错误
   - 记录日志
   - 显示错误页面

理由：
1. 分层处理，职责清晰
2. 用户体验友好
3. 便于调试
4. 防止应用崩溃

### 后果
- 需要定义错误码表
- 需要实现错误边界组件
- 需要实现错误记录（日志）
- 所有异步操作需要try-catch

---

## 决策总结

| 决策 | 选择 | 理由 |
|------|------|------|
| 文件格式 | JSON | 可读、兼容、易调试 |
| 加密算法 | AES-256-GCM | 认证加密、防篡改 |
| 密码哈希 | bcrypt (10轮) | 安全、抗GPU破解 |
| 数据库 | SQLite | 轻量、零配置 |
| 通信方式 | HTTP + IPC混合 | 标准RESTful + 系统操作 |
| 最近工程 | SQLite + MobX缓存 | 性能 + 持久化 |
| 列表渲染 | 虚拟滚动 | 性能优秀 |
| 分类管理 | 预设 + 自定义 | 平衡灵活性和规范性 |
| 搜索方式 | 前端实时 + 防抖 | 无延迟、用户体验好 |
| 错误处理 | 分层处理 | 职责清晰、用户友好 |

---

## 相关文档

- 技术方案: SOL-002
- 功能需求: FE-002
- 用户故事: US-002

---

**文档版本**: 1.0
**最后更新**: 2026-01-21
**审批人**: 待审批
