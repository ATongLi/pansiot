# REQ-007: 云平台账号系统 - 多租户组织管理与RBAC权限控制

## 元数据
- **需求ID**: REQ-007
- **创建日期**: 2026-01-26
- **创建人**: Claude Code
- **优先级**: P0 (关键功能)
- **状态**: 草稿 v3.2 (根据反馈完善)
- **相关平台**: 云平台 (Cloud)

## 需求描述

### 业务背景
云平台系统需要实现多租户系统，平台面向企业组织类型的租户使用。物联网平台是一个典型的多租户平台，主要用户包括：

1. **系统集成商**：作为一级租户，为下游客户提供物联网服务
2. **下游客户企业**：作为二级租户，使用集成商提供的设备管理和监控服务
3. **平台超管**：根管控主体，管理整个平台

### 核心业务场景

#### 场景1：三层租户架构
- **集成商（一级管控主体）**：管理下游客户，查看所有下游数据
- **下游客户（二级业务主体）**：管理内部用户，仅查看自身数据
- **跨主体严格隔离**：不同集成商之间、同集成商不同下游之间互不可见

#### 场景2：租户类型与层级管理

**租户类型**：
- **终端租户（TERMINAL）**：最终使用租户，通常是下游客户
- **集成商租户（INTEGRATOR）**：一级管控主体，可以创建和管理下游租户

**组织实体属性**：
- **基础属性**：企业名称、所属行业、企业序列号
- **租户类型**：`tenant_type`（TERMINAL/INTEGRATOR）
- **层级关系**：
  - `managed_tenant_id`（管理租户ID）：标识租户由哪个集成商管理
    - 对于终端租户：指向其管理集成商
    - 对于集成商租户：为NULL（由平台直接管理）
  - `parent_tenant_id`（父租户ID）：标识直接上级组织
    - 支持多级层级（集成商 → 一级下游 → 二级下游 → ...）
    - 用于组织树形结构和权限继承

**关键区别**：
- **管理租户（managed_tenant_id）**：
  - 总是指向集成商租户
  - 用于数据隔离和权限管控
  - 集成商可以查看所有managed_tenant_id指向自己的下游数据

- **父租户（parent_tenant_id）**：
  - 指向直接上级组织（可能是集成商或其他下游租户）
  - 用于组织层级展示和权限继承
  - 支持多级嵌套（下游客户可以创建子组织）

**示例场景**：
```
集成商A (tenant_type=INTEGRATOR, managed_tenant_id=NULL, parent_tenant_id=NULL)
  ├─ 下游客户B (tenant_type=TERMINAL, managed_tenant_id=集成商A, parent_tenant_id=集成商A)
  │   └─ 子组织C (tenant_type=TERMINAL, managed_tenant_id=集成商A, parent_tenant_id=下游客户B)
  └─ 下游客户D (tenant_type=TERMINAL, managed_tenant_id=集成商A, parent_tenant_id=集成商A)
```

#### 场景3：用户注册与租户用户创建

**方式1：新企业注册（创建新租户）**
- 用户输入企业组织名称，系统自动生成一个新租户
- 注册用户自动成为该租户的**系统管理员**
- 系统自动生成不可删除的"系统管理员"角色
- 系统管理员默认拥有所有权限
- 支持手机号/邮箱注册（带国际区号支持）
- 必填项：企业名称、所属行业（预设选项+自定义）
- 手机号/邮箱验证码验证（可mock）

**方式2：加入已有企业**
- 勾选"已有企业"选项
- 输入企业序列号（系统全局唯一）
- 自动加入对应租户

**企业序列号生成规则**：
- **最终格式**：`{4位随机字符}{4位自增ID}`
  - **示例**：`A3F20001`（总长度8位）
  - **前缀（4位）**：随机字符（大小写字母+数字）- 避免被猜测
  - **后缀（4位）**：自增ID - 保证唯一性
- **特点**：
  - 极简长度（8位），非常便于用户输入和记忆
  - 全局唯一，不会重复
  - 不易被猜测和枚举
  - 生成效率高
- **输入界面**：自动格式化为 `XXXX XXXX`（4-4格式），便于阅读和校验

**方式3：租户内创建用户（仅租户管理员）**
- 租户管理员可以在租户下创建子用户
- 创建流程：
  1. 填写用户基本信息（用户名、手机号/邮箱）
  2. 发送验证码到用户手机/邮箱
  3. 验证码验证通过后创建用户
  4. 设置初始密码或由用户首次登录时设置
  5. 分配角色和权限
- 支持批量创建用户（CSV导入）
- 创建的用户自动关联到当前租户

#### 场景4：RBAC权限模型
**三层权限架构**：
1. **系统角色**：预定义角色（系统管理员、普通用户等）
2. **功能权限**：针对功能标签页（页面级）
3. **操作权限**：针对功能按钮（操作级：删除、新增、查看）

**权限配置**：
- 角色可配置多个功能权限
- 功能权限可包含多个操作权限
- 租户管理员可自定义角色和权限分配

#### 场景5：租户角色切换
- 租户初始角色：下游终端用户
- 可通过"开通功能"升级为集成商角色
- 集成商角色可创建和管理下游客户

#### 场景6：租户资源创建的字段继承规则

**核心规则**：所有租户下创建的对象实体/业务表，都必须包含两个关键字段：
- **`tenant_id`**（归属租户ID）：标识资源归属哪个租户
- **`managed_tenant_id`**（管理租户ID）：标识资源由哪个集成商管控

**字段继承逻辑**：

**场景6.1：终端租户创建资源**
```
当前用户：终端租户A的管理员
创建资源：设备、告警规则、报表等

自动填充：
- tenant_id = 终端租户A的ID
- managed_tenant_id = 终端租户A的managed_tenant_id（指向集成商I）

结果：
- 资源归属终端租户A
- 集成商I可以查看此资源
- 终端租户A可以修改此资源
```

**场景6.2：集成商创建资源并归属自己**
```
当前用户：集成商I的管理员
创建资源：设备、告警规则等
归属选择：集成商自己（默认）

自动填充：
- tenant_id = 集成商I的ID
- managed_tenant_id = NULL（集成商自己的资源）

结果：
- 资源归属集成商I
- 只有集成商I可以查看和修改
```

**场景6.3：集成商创建资源并归属下游租户**
```
当前用户：集成商I的管理员
创建资源：设备
归属选择：下游租户A（通过"归属组织"字段选择）

自动填充：
- tenant_id = 下游租户A的ID
- managed_tenant_id = 集成商I的ID（管理租户始终是集成商自己）

结果：
- 资源归属下游租户A（tenant_id指向A）
- 集成商I可以查看此资源（managed_tenant_id指向I）
- 下游租户A可以使用此资源
- 资源的实际管理权仍在集成商I

业务价值：
- 集成商代客户创建设备后，仍可以查看和管理
- 客户可以看到并使用设备
- 数据权限清晰，不产生数据混乱
```

**适用范围**：
所有业务表都包含这两个字段：
- 设备表（devices）
- 用户表（users）
- 告警表（alerts）
- 日志表（logs）
- 数据点表（data_points）
- 仪表板表（dashboards）
- 报表表（reports）
- 任何其他业务对象表

**字段约束**：
- `tenant_id`：NOT NULL，必须有明确归属
- `managed_tenant_id`：
  - 集成商租户创建的资源：NULL
  - 终端租户创建的资源：指向其管理集成商
  - 集成商为下游创建的资源：指向集成商自己

#### 场景7：集成商资源创建界面的动态交互

**前端界面动态识别规则**：

**规则7.1：自动识别租户类型**
系统根据当前登录用户的租户类型（tenant_type）自动调整界面：
- **集成商租户（INTEGRATOR）**：显示"归属组织"字段
- **终端租户（TERMINAL）**：隐藏"归属组织"字段，自动填充为当前租户

**规则7.2："归属组织"字段的动态行为**

**场景7.2.1：集成商创建资源的界面**
```
界面元素：
┌─────────────────────────────────────┐
│ 创建设备                             │
├─────────────────────────────────────┤
│ 设备名称: [____________]             │
│ 设备类型: [下拉选择]                 │
│ 归属组织: [请选择下游租户 ▼] ← 动态显示 │
│   ├── 集成商自己（默认）              │
│   ├── 下游客户A                      │
│   ├── 下游客户B                      │
│   └── 下游客户C                      │
│ 备注: [____________]                 │
│                                     │
│ [取消]  [创建]                       │
└─────────────────────────────────────┘

字段说明：
- "归属组织"字段是一个下拉选择器
- 默认值：集成商自己
- 可选项：集成商自己 + 所有下游租户
- 选择后，tenant_id自动设置为选中的租户ID
- managed_tenant_id始终设置为集成商自己的ID
```

**场景7.2.2：终端租户创建资源的界面**
```
界面元素：
┌─────────────────────────────────────┐
│ 创建设备                             │
├─────────────────────────────────────┤
│ 设备名称: [____________]             │
│ 设备类型: [下拉选择]                 │
│ 归属组织: 当前组织（只读）← 隐藏选择器 │
│ 备注: [____________]                 │
│                                     │
│ [取消]  [创建]                       │
└─────────────────────────────────────┘

字段行为：
- "归属组织"字段隐藏或显示为只读
- 自动填充为当前用户所属租户
- 用户无法修改
- tenant_id自动设置为当前租户ID
- managed_tenant_id自动设置为当前租户的managed_tenant_id
```

**规则7.3：数据提交时的字段处理**

**集成商创建资源时的后端处理**：
```javascript
// 前端提交数据
{
  "device_name": "设备001",
  "device_type": "传感器",
  "tenant_id": "下游客户A的ID",  // 用户选择的归属组织
  // managed_tenant_id 由后端自动设置为集成商自己
}

// 后端自动处理
POST /api/devices
{
  "device_name": "设备001",
  "device_type": "传感器",
  "tenant_id": "下游客户A的ID",
  "managed_tenant_id": "集成商I的ID",  // ← 后端自动设置为当前集成商ID
  "created_by": "当前用户ID"
}
```

**关键点**：
- 集成商将资源归属到终端租户时，`managed_tenant_id`前端自动填充为集成商自己的ID
- 后端验证：`managed_tenant_id`必须是当前集成商租户的ID
- 前端可以传递`managed_tenant_id`，也可以不传（由后端自动设置）

**终端租户创建资源时的后端处理**：
```javascript
// 前端提交数据
{
  "device_name": "设备002",
  "device_type": "传感器",
  // tenant_id 和 managed_tenant_id 由后端自动设置
}

// 后端自动处理
POST /api/devices
{
  "device_name": "设备002",
  "device_type": "传感器",
  "tenant_id": "终端租户A的ID",  // 当前用户所属租户
  "managed_tenant_id": "集成商I的ID",  // 继承自当前租户
  "created_by": "当前用户ID"
}
```

**规则7.4：字段显示逻辑**

| 当前用户租户类型 | "归属组织"字段 | 默认值 | 可否修改 |
|-----------------|--------------|--------|---------|
| 集成商租户 | 显示下拉选择器 | 集成商自己 | 可选择下游租户 |
| 终端租户 | 隐藏或只读 | 当前租户 | 不可修改 |

**规则7.5：界面提示信息**

集成商创建资源时，界面显示友好提示：
- "选择资源归属的组织。如果选择下游租户，该租户可以使用此资源，但管理权仍在您的集成商。"
- "您可以为下游客户创建资源，这样客户可以立即使用，同时您可以监控和管理。"

**前端实现要点**：
1. 在资源创建表单中，根据`current_user.tenant_type`动态显示/隐藏"归属组织"字段
2. "归属组织"下拉选项：
   - 如果是集成商：显示[集成商自己] + [所有下游租户列表]
   - 如果是终端租户：不显示下拉，只显示当前租户名称
3. 提交时：
   - 集成商：使用用户选择的tenant_id
   - 终端租户：使用当前用户的tenant_id
4. 集成商将资源归属到终端租户时，`managed_tenant_id`前端自动填充为集成商自己的ID
5. 后端验证：`managed_tenant_id`必须是当前集成商租户的ID

#### 场景8：功能模块与配额管理系统

**核心概念**：
- **功能模块（Feature Module）**：平台的功能单元，如设备管理、Web工程编辑器、数据看板、告警服务等
- **配额（Quota）**：每个功能模块的资源使用限制
- **配额分配**：集成商可以将自己的配额分配给下游租户

**8.1：系统默认功能模块清单**

平台预设功能模块，分为**系统默认功能**和**可选功能**：

| 模块代码 | 模块名称 | 类型 | 说明 | 默认配额 |
|---------|---------|------|------|---------|
| `system_config` | 系统配置 | 系统默认 | 基础系统设置，所有租户默认拥有 | 无限制 |
| `user_management` | 用户管理 | 系统默认 | 租户内用户创建和管理 | 无限制 |
| `role_management` | 角色管理 | 系统默认 | 角色和权限配置 | 无限制 |
| `device_management` | 设备管理 | 可选 | 设备接入和管理 | 可配额 |
| `web_editor` | Web工程编辑器 | 可选 | Web可视化工程编辑 | 可配额 |
| `data_dashboard` | 数据看板 | 可选 | 数据可视化看板 | 可配额 |
| `alert_service` | 告警服务 | 可选 | 告警规则和通知 | 可配额 |
| `data_storage` | 数据存储 | 可选 | 历史数据存储 | 可配额（GB） |
| `api_access` | API访问 | 可选 | API调用次数 | 可配额（次/月） |

**系统默认功能**：
- 租户创建后自动拥有，无需开通
- 前端默认显示，无法隐藏
- 无使用配额限制（或设置很高的默认值）

**可选功能**：
- 需要平台超管或集成商开通
- 前端根据开通情况显示/隐藏
- 有配额限制，使用时消耗配额

**8.2：平台后台功能开通管理**

**平台超管管理界面**：
```
功能模块管理
├─ 模块列表（显示所有预设模块）
├─ 模块类型标识（系统默认/可选）
├─ 全局配额设置（每个模块的默认配额）
└─ 模块状态（启用/禁用）

租户功能开通
├─ 选择租户
├─ 显示当前已开通功能
├─ 开通新功能（勾选可选模块）
├─ 设置租户配额（覆盖默认配额）
└─ 保存开通记录
```

**开通流程**：
1. 平台超管进入"租户管理" → 选择租户 → "功能开通"
2. 系统显示功能模块列表（区分系统默认和可选）
3. 勾选要开通的可选模块
4. 为每个模块设置配额：
   - 子租户数量（如：100个）
   - Web工程数量（如：50个）
   - 设备数量（如：1000台）
   - 数据存储空间（如：100GB）
   - API调用次数（如：10000次/月）
5. 保存后，租户可以查看和使用开通的功能

**前端展示规则**：
- 已开通的功能：在导航菜单和页面中显示
- 未开通的功能：完全隐藏，用户看不到入口
- 系统默认功能：始终显示，无法隐藏

**8.3：集成商对下游租户的功能开通**

**开通范围限制**：
- 集成商只能开通自己拥有的功能给下游租户
- 如果集成商自己没有某个功能，无法给下游开通
- 下游租户的功能范围 ≤ 集成商的功能范围

**开通界面**：
```
集成商：管理下游客户A
├─ 功能开通
│   ├─ 显示集成商当前拥有的功能列表
│   ├─ 勾选要给客户A开通的功能
│   └─ 分配配额（不能超过集成商自己的剩余配额）
│       ├─ 子租户数量：集成商剩余50 → 分配给客户A 20
│       ├─ Web工程数量：集成商剩余30 → 分配给客户A 10
│       └─ 设备数量：集成商剩余200 → 分配给客户A 50
```

**配额传递逻辑**：
- 集成商的总配额 = 平台超管分配的配额
- 集成商剩余配额 = 总配额 - 已分配给所有下游的配额 - 自己已使用的配额
- 分配给下游后，集成商剩余配额相应减少

**8.4：配额分配与统计**

**配额分配流程**：
```
1. 平台超管分配给集成商I
   device_management: 1000台设备
   web_editor: 50个工程

2. 集成商I自己使用
   device_management: 已用200台
   web_editor: 已用10个

3. 集成商I分配给下游客户A
   device_management: 分配300台
   web_editor: 分配15个

4. 集成商I剩余可用配额
   device_management: 1000 - 200 - 300 = 500台
   web_editor: 50 - 10 - 15 = 25个
```

**资源使用统计表**：

**表名**：`tenant_quota_usage`

| 字段 | 类型 | 说明 |
|-----|------|------|
| `id` | BIGINT PK | 主键 |
| `tenant_id` | BIGINT NOT NULL | 租户ID |
| `module_code` | VARCHAR(50) NOT NULL | 功能模块代码 |
| `total_quota` | INT | 总配额 |
| `used_quota` | INT | 已使用配额 |
| `remaining_quota` | INT | 剩余配额 |
| `allocated_quota` | INT | 已分配给下游的配额（仅集成商） |
| `updated_at` | TIMESTAMP | 更新时间 |
| 索引：`idx_tenant_module`, `idx_remaining` |

**配额计算规则**：
- **终端租户**：
  - `remaining_quota` = `total_quota` - `used_quota`
  - `allocated_quota` = NULL（终端租户不分配配额）

- **集成商租户**：
  - `available_quota` = `total_quota` - `used_quota` - `allocated_quota`
  - `remaining_quota` = `total_quota` - `used_quota`（用于显示）
  - `allocated_quota` = 已分配给所有下游租户的配额总和

**配额检查时机**：
- 创建子租户时：检查子租户数量配额
- 创建设备时：检查设备数量配额
- 创建Web工程时：检查工程数量配额
- API调用时：检查API调用次数配额
- 存储数据时：检查存储空间配额

**配额不足处理**：
- 前端提示：配额不足，无法创建
- 显示配额使用情况：已用XX/总共XX
- 提示联系集成商或平台超管增加配额

**8.5：前端界面动态显示**

**显示规则**：
```javascript
// 前端伪代码
function showFeatureModule(moduleCode) {
  // 1. 检查当前租户是否开通该功能
  const isActivated = checkTenantFeature(tenantId, moduleCode);

  // 2. 系统默认功能始终返回true
  const isSystemDefault = checkSystemDefault(moduleCode);

  // 3. 显示或隐藏功能模块
  if (isActivated || isSystemDefault) {
    showModule(moduleCode);
  } else {
    hideModule(moduleCode); // 完全隐藏，不显示入口
  }
}
```

**集成商视图**：
- 显示所有已开通功能
- 显示每个功能的配额使用情况（已用/总共/剩余）
- 显示已分配给下游的配额
- 提供配额管理入口

**终端租户视图**：
- 只显示已开通功能
- 显示每个功能的配额使用情况（已用/总共/剩余）
- 不显示配额分配功能

#### 场景9：系统日志设计

**核心设计原则**：
- **灵活扩展**：支持快速添加新的日志类型，无需修改核心日志逻辑
- **统一规范**：所有模块遵循相同的日志记录规范
- **性能优先**：日志记录不影响业务性能
- **审计合规**：满足安全和审计要求

**9.1：日志数据模型设计**

**表名**：`audit_logs`

| 字段 | 类型 | 说明 |
|-----|------|------|
| `id` | BIGINT PK | 日志ID |
| `tenant_id` | BIGINT NOT NULL | 租户ID |
| `module_code` | VARCHAR(50) | 模块代码（如：device, user, alert） |
| `action_type` | VARCHAR(20) | 操作类型（CREATE, UPDATE, DELETE, LOGIN, LOGOUT等） |
| `entity_type` | VARCHAR(50) | 实体类型（如：Device, User, AlertRule） |
| `entity_id` | BIGINT | 实体ID（业务对象的ID） |
| `action_detail` | JSON | 操作详情（字段级变更记录） |
| `operator_id` | BIGINT NOT NULL | 操作人ID |
| `operator_name` | VARCHAR(100) | 操作人姓名（冗余字段，便于查询） |
| `ip_address` | VARCHAR(45) | 操作IP地址 |
| `user_agent` | VARCHAR(500) | 用户代理（浏览器信息） |
| `status` | VARCHAR(20) | 操作状态（SUCCESS, FAILED, PARTIAL） |
| `error_message` | TEXT | 错误信息（如果失败） |
| `created_at` | TIMESTAMP NOT NULL | 操作时间 |
| 索引：`idx_tenant_module`, `idx_entity`, `idx_operator`, `idx_created_at`, `idx_action` |

**9.2：操作类型（action_type）定义**

**标准操作类型**：
| 操作类型 | 代码 | 说明 | 示例 |
|---------|------|------|------|
| 创建 | CREATE | 创建新对象 | 创建设备、创建用户 |
| 查询 | READ | 查询对象 | 查看设备详情（可选记录） |
| 更新 | UPDATE | 修改对象 | 修改设备名称、更新用户信息 |
| 删除 | DELETE | 删除对象 | 删除设备、删除用户 |
| 登录 | LOGIN | 用户登录 | 用户登录成功 |
| 登出 | LOGOUT | 用户登出 | 用户主动登出 |
| 导出 | EXPORT | 导出数据 | 导出设备列表 |
| 导入 | IMPORT | 导入数据 | 批量导入用户 |
| 分配 | ALLOCATE | 分配配额 | 分配配额给下游租户 |
| 开通 | ACTIVATE | 开通功能 | 为租户开通功能模块 |
| 停用 | DEACTIVATE | 停用功能 | 停用租户功能模块 |

**9.3：日志记录规范**

**必须记录的操作**（关键业务）：
- ✅ 所有增删改操作（CREATE, UPDATE, DELETE）
- ✅ 登录登出操作（LOGIN, LOGOUT）
- ✅ 权限变更操作（角色分配、权限修改）
- ✅ 配额分配操作（ALLOCATE）
- ✅ 功能开通操作（ACTIVATE, DEACTIVATE）
- ✅ 敏感配置修改（系统配置、安全设置）

**可选记录的操作**（根据业务需求）：
- ⭕ 查询操作（READ）- 可配置是否记录
- ⭕ 导入导出（IMPORT, EXPORT）- 建议记录
- ⭕ API调用 - 可通过中间件统一记录

**不记录的操作**：
- ❌ 健康检查、心跳检测
- ❌ 定时任务、系统调度
- ❌ 统计分析、报表生成

**9.4：操作详情（action_detail）设计**

**JSON格式，记录字段级变更**：

**示例1：创建设备**
```json
{
  "before": null,
  "after": {
    "device_id": 12345,
    "device_name": "温度传感器01",
    "device_type": "sensor",
    "tenant_id": 1001,
    "managed_tenant_id": 1
  },
  "changes": null
}
```

**示例2：更新设备**
```json
{
  "before": {
    "device_name": "温度传感器01",
    "status": "offline"
  },
  "after": {
    "device_name": "温度传感器01-已更新",
    "status": "online"
  },
  "changes": [
    {"field": "device_name", "old": "温度传感器01", "new": "温度传感器01-已更新"},
    {"field": "status", "old": "offline", "new": "online"}
  ]
}
```

**示例3：删除设备**
```json
{
  "before": {
    "device_id": 12345,
    "device_name": "温度传感器01",
    "device_type": "sensor"
  },
  "after": null,
  "changes": null
}
```

**9.5：日志中间件设计**

**自动记录机制**：
```javascript
// 日志中间件伪代码
function auditLogMiddleware(req, res, next) {
  const startTime = Date.now();

  // 捕获响应
  const originalSend = res.send;
  res.send = function(data) {
    // 记录日志
    logAction({
      tenant_id: req.user.tenant_id,
      module_code: req.moduleCode, // 从路由或配置中获取
      action_type: req.method, // GET/POST/PUT/DELETE 映射到 READ/CREATE/UPDATE/DELETE
      entity_type: req.entityType, // 从路由参数中获取，如 'device'
      entity_id: req.params.id,
      action_detail: {
        before: req.oldData,
        after: req.newData,
        changes: req.changes
      },
      operator_id: req.user.id,
      operator_name: req.user.name,
      ip_address: req.ip,
      user_agent: req.get('User-Agent'),
      status: res.statusCode < 400 ? 'SUCCESS' : 'FAILED',
      error_message: res.statusMessage,
      created_at: new Date()
    });

    originalSend.call(res, data);
  };

  next();
}
```

**配置化日志记录**：
```yaml
# audit_log_config.yml
modules:
  device:
    enabled: true
    log_read: false  # 不记录查询操作
    log_write: true   # 记录增删改
  user:
    enabled: true
    log_read: false
    log_write: true
    log_login: true   # 记录登录登出
  alert:
    enabled: true
    log_read: false
    log_write: true
  system_config:
    enabled: true
    log_read: true    # 系统配置所有操作都记录
    log_write: true
```

**9.6：快速扩展新模块日志**

**添加新模块日志只需3步**：

1. **在配置文件中添加模块配置**：
```yaml
new_feature:
  enabled: true
  log_read: false
  log_write: true
```

2. **在路由中指定模块代码和实体类型**：
```javascript
router.post('/api/new_feature',
  setModuleContext('new_feature', 'NewFeature'),  // 中间件设置上下文
  auditLogMiddleware,  // 日志中间件
  controller.create
);
```

3. **无需修改日志表结构**，日志系统自动支持

**9.7：日志查询与展示**

**日志查询界面**：
- 按模块筛选（设备、用户、告警等）
- 按操作类型筛选（创建、更新、删除等）
- 按时间范围筛选（今天、最近7天、最近30天、自定义）
- 按操作人筛选
- 按关键字搜索（实体名称、操作详情）

**日志详情展示**：
- 操作时间
- 操作人信息
- 操作类型
- 实体类型和ID
- 操作详情（JSON格式，支持高亮显示变更）
- IP地址和设备信息
- 操作状态（成功/失败）

**日志导出**：
- 支持导出为Excel/CSV
- 支持按筛选条件导出
- 敏感信息脱敏（密码、密钥等）

**9.8：日志保留与归档**

**日志保留策略**：
- 在线日志：保留最近6个月
- 归档日志：超过6个月的日志压缩归档
- 审计日志：重要操作日志永久保留（独立存储）

**日志清理**：
- 定时任务清理超过保留期的在线日志
- 归档日志存储到低成本存储
- 提供日志恢复接口（按需查询归档日志）

### 数据隔离设计

#### 统一字段命名规范
所有业务表（设备、用户、告警、日志等）包含两个统一命名的字段：
- **`tenant_id`**（归属租户ID）：标识数据归属的租户
  - 数据创建时自动设置为当前用户所属租户ID
  - 用于租户数据隔离

- **`managed_tenant_id`**（管理租户ID）：标识数据的管控集成商
  - 数据创建时自动设置为当前租户的managed_tenant_id
  - 用于集成商查看所有下游数据
  - 集成商租户创建的数据，此字段为NULL

#### 数据隔离规则
**场景1：终端租户查看数据**
```sql
-- 只能看到自己创建的数据
WHERE tenant_id = {current_tenant_id}
```

**场景2：集成商查看数据**
```sql
-- 可以看到所有下游租户的数据
WHERE managed_tenant_id = {integrator_tenant_id}
```

**场景3：平台超管查看数据**
```sql
-- 可以看到所有数据（无过滤）
-- 或者查看所有集成商的数据
WHERE managed_tenant_id IN (
  SELECT tenant_id FROM tenants
  WHERE tenant_type = 'INTEGRATOR'
)
```

**场景4：跨集成商隔离**
```sql
-- 集成商A不能看到集成商B管理的下游数据
WHERE managed_tenant_id = {current_integrator_tenant_id}  -- 自动过滤其他集成商
```

#### 租户内角色与用户隔离
- 每个租户独立创建角色（role表关联tenant_id）
- 每个租户独立创建用户（user表关联tenant_id）
- 租户管理员只能管理本租户的角色和用户
- 集成商可以查看所有下游租户的用户列表，但不能跨租户修改

### 界面简化需求
- 非集成商类型账号：隐藏"归属"选项，自动填充字段
- 未开通下游客户功能：隐藏子组织管理功能
- 降低用户理解复杂度，根据租户类型动态显示功能

## 业务价值

### 对集成商的价值
1. **统一管控**：在一个平台上管理所有下游客户的设备和数据
2. **权责分层**：集成商负责创建和管理下游客户账号
3. **数据洞察**：查看整个业务链条的数据，提供增值服务

### 对下游客户的价值
1. **独立使用**：拥有独立的组织和管理界面
2. **数据隔离**：只能看到自己的数据，保障隐私
3. **降低成本**：无需自建IoT平台，按需使用

### 对平台的价值
1. **多租户支持**：实现真正的SaaS多租户架构
2. **可扩展性**：支持无限层级和组织扩展
3. **安全性**：严格的权限控制和数据隔离

## 验收标准

### 功能验收标准
- [ ] **组织管理**：
  - [ ] 支持创建多级组织（集成商→下游客户→子组织）
  - [ ] 组织实体包含managed_tenant_id和parent_tenant_id字段
  - [ ] 每个组织生成唯一的企业序列号
  - [ ] 支持组织的增删改查操作

- [ ] **用户注册**：
  - [ ] 支持新企业注册（自动创建组织+系统管理员角色）
  - [ ] 支持通过企业序列号加入已有企业
  - [ ] 支持手机号/邮箱注册（含国际区号）
  - [ ] 实现验证码验证（可mock）
  - [ ] 必填项验证：企业名称、所属行业

- [ ] **RBAC权限**：
  - [ ] 实现三级权限架构（系统角色→功能权限→操作权限）
  - [ ] 注册时自动生成不可删除的系统管理员角色
  - [ ] 系统管理员默认拥有所有权限
  - [ ] 支持自定义角色和权限配置
  - [ ] 权限粒度到功能按钮级（删除、新增、查看）

- [ ] **租户管理**：
  - [ ] 实现租户角色切换（终端用户↔集成商）
  - [ ] 集成商可创建和管理下游客户
  - [ ] 所有业务表包含tenant_id和managed_tenant_id字段
  - [ ] 实现数据单向可视（集成商看下游，下游看自己）

- [ ] **前端界面**：
  - [ ] 实现注册页面和登录页面
  - [ ] 根据租户类型动态显示功能
  - [ ] 非集成商隐藏"归属"选项
  - [ ] 未开通下游功能的租户隐藏子组织管理

- [ ] **后端API**：
  - [ ] 组织管理API（增删改查）
  - [ ] 用户管理API（增删改查）
  - [ ] 角色管理API（增删改查）
  - [ ] 权限验证中间件
  - [ ] 登录注销API

### 性能验收标准
- [ ] 组织查询响应时间 < 200ms
- [ ] 权限验证响应时间 < 50ms
- [ ] 支持至少10万级租户并发

### 安全验收标准
- [ ] 不同租户数据严格隔离
- [ ] 权限验证无漏洞
- [ ] 企业序列号不可猜测
- [ ] 敏感操作需要二次验证

### 可用性验收标准
- [ ] 界面简洁，用户3步内完成注册
- [ ] 根据租户类型自动适配界面
- [ ] 提供清晰的权限配置向导

## 关联需求
- **父需求**: 无（根需求）
- **子需求**: 无（待分解）
- **依赖需求**:
  - 无（云平台独立功能）
- **冲突需求**:
  - 无

## 风险和限制

### 技术风险
1. **多租户数据隔离复杂性**：需要仔细设计数据查询逻辑，确保数据隔离无漏洞
2. **RBAC权限模型复杂度**：三级权限架构可能导致权限配置复杂，需要良好的UI设计
3. **组织层级查询性能**：多级组织可能影响查询性能，需要优化索引和查询策略

### 业务风险
1. **租户角色切换逻辑**：从终端用户升级为集成商可能涉及数据迁移
2. **下游客户数据归属**：当集成商关系终止时，数据如何处理需要明确

### 限制条件
1. **企业序列号唯一性**：必须保证全局唯一，避免冲突
2. **系统管理员角色不可删除**：需要数据库层面约束
3. **验证码服务**：初期可使用mock，但需要预留真实服务接口

## 技术参考

### 核心设计原则
- **三层租户架构**：平台超管 → 集成商 → 下游客户
- **租户级RBAC**：每个租户独立的权限体系
- **权责分层**：集成商管下游，下游管内部
- **数据单向可视**：集成商看所有下游，下游仅看自身
- **跨主体严格隔离**：不同集成商/同集成商不同下游互不可见

### 数据模型要点
- 所有业务表包含`tenant_id`和`managed_tenant_id`字段
- 组织表包含`managed_tenant_id`和`parent_tenant_id`字段
- 角色表、权限表、用户角色关联表支持灵活的RBAC

## 变更历史
| 日期 | 版本 | 变更内容 | 变更人 |
|------|------|---------|--------|
| 2026-01-26 | 1.0 | 初始创建 | Claude Code |
| 2026-01-26 | 2.0 | 根据反馈完善：1. 添加租户类型字段（tenant_type） 2. 区分managed_tenant_id和parent_tenant_id 3. 添加租户内创建用户功能（需验证码） | Claude Code |
| 2026-01-26 | 3.0 | 补充场景6和场景7：1. 租户资源创建的字段继承规则 2. 集成商资源创建界面的动态交互（"归属组织"字段自动识别） | Claude Code |
| 2026-01-26 | 3.1 | 字段命名优化：将managed_by_tenant_id简化为managed_tenant_id | Claude Code |
| 2026-01-27 | 3.2 | 企业序列号精简：从15位简化为8位（4位随机字符+4位自增ID） | Claude Code |
